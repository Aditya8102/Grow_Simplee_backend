# -*- coding: utf-8 -*-
"""Untitled24.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Cem6hEhF_HGJbMzgcmL-GRg7FIppBqdR
"""

!pip install ortools
!pip install googlemaps

import ortools
import googlemaps
import pandas as pd
import numpy as np
import requests
import urllib.request
import json
import math
from __future__ import print_function
from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp
#Reading csv of dispatch locations and creating list of addresses

def delivery(delivery_addlink,delivery_demandslink,API_KEY):
  def read_address(delivery_addlink):
    dfd = pd.read_csv(delivery_addlink)
    datalistd= dfd['address'].to_list()
    dfd1 = pd.read_csv(delivery_addlink)
    add= dfd1['address'].to_list()
    dfd2 = pd.read_csv(delivery_addlink)
    awb= dfd2['AWB'].to_list()
    delivery_add=datalistd # list of addreses->delivery_add
    
    #convert addresses to lat and long
    latitude_delivery=[]
    longitude_delivery=[]
    for i in range(len(datalistd)):
      datalistd[i] = datalistd[i].replace(" ","+")
    for i in range(len(datalistd)):
      r = requests.get('https://maps.googleapis.com/maps/api/geocode/json?address=' + datalistd[i] +'&key=' + API_KEY)
      resp = json.loads(r.text)
      lat = resp['results'][0]['geometry']['location']['lat']
      lon = resp['results'][0]['geometry']['location']['lng']
      latitude_delivery.append(lat)
      longitude_delivery.append(lon)
    
    # return(latitude_delivery)
    return delivery_add,add,awb,datalistd,latitude_delivery,longitude_delivery

  def time_calculator(lon1, lat1, lon2, lat2):
    lon1, lat1, lon2, lat2 = map(np.radians, [lon1, lat1, lon2, lat2])
    newlon = lon2 - lon1
    newlat = lat2 - lat1
    haver_formula = np.sin(newlat/2.0)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(newlon/2.0)**2
    dist = 2 * np.arcsin(np.sqrt(haver_formula ))
    m = 6367 * dist *1000
    time=m/6.11
    return int(math.floor(time))

  #creating time matrix from disptach loctions 
  def create_time_matrix(latitude_delivery,longitude_delivery):
    time_matrix = np.zeros((len(latitude_delivery),len(longitude_delivery)))
    for i in range(len(longitude_delivery)):
      for j in range(len(longitude_delivery)):
        # calculate the distance using the distance matrix function
        time_matrix[i, j] = time_calculator(longitude_delivery[i], latitude_delivery[i],longitude_delivery[j],latitude_delivery[j])
    return time_matrix

  # creating time_windows:
  def create_time_windows(delivery_add):
      time_windows = []
      for i in range(len(delivery_add)):
         time_windows.append((0,360*60))
      return time_windows
  

  # creating demands list
  # file needs to be uploaded
  def read_demands(delivery_demandslink):
    demands=[]  
    dd=pd.read_csv(delivery_demandslink)
    demands1=dd['demand'].to_list()
    for i in range(len(demands1)):
      demands.append(demands1[i])
    return demands

  def vehicles_number(delivery_add):
      num_vehicles=math.floor(len(delivery_add)/20)
      return num_vehicles

  # adding vehicle capacities
  def delivery_capacity(num_vehicles):
    vehicle_capacities=[640000]*num_vehicles
    return vehicle_capacities

  def delivery_vrp(time_matrix1,initial_route_of_delivery,time_windows,num_vehicles,demands,vehicle_capacities,depot_index):
    
    time_limit_seconds = 300 # time limit for calculation #could be calculated later
    def create_data_model(time_matrix, time_windows, num_vehicles, demands, vehicle_capacities, depot_index):
        """Stores the data for the problem."""
        
        data = {}
        data['time_matrix'] = time_matrix1
        data['time_windows'] = time_windows
        data['num_vehicles'] = num_vehicles
        data['demands'] = demands
        data['vehicle_capacities'] =vehicle_capacities
        data['depot'] = depot_index
        return data
    """Capacitated Vehicles Routing Problem (CVRP) with Time Windows."""
       #For getting the list of final time of each delivery man
    #Route of each driver with its node number,time of delivery and quantity it is carrying 
    def print_solution(data, manager, routing, solution):
        """Prints solution on console."""
        total_distance = 0
        total_load = 0
        time_dimension = routing.GetDimensionOrDie('Time')
        total_time = 0
        time_ss = []
        
        for vehicle_id in range(data['num_vehicles']):
            index = routing.Start(vehicle_id)
            plan_output = 'Route for vehicle {}:\n'.format(vehicle_id)
            route_load = 0
            while not routing.IsEnd(index):
                node_index = manager.IndexToNode(index)
                time_var = time_dimension.CumulVar(index)
                route_load += data['demands'][node_index]
                plan_output += 'Place {0:>2} Arrive at {2:>2}sec Depart at {3:>2}sec (Load {1:>2})\n'.format(manager.IndexToNode(index), route_load,solution.Min(time_var), solution.Max(time_var))
                time_ss.append([manager.IndexToNode(index),solution.Max(time_var),route_load])
                # output_list.append('{0}'.format(manager.IndexToNode(index)))
                previous_index = index
                index = solution.Value(routing.NextVar(index))
                
           
            initial_route_of_delivery[vehicle_id]=time_ss
            # time_list2.append(time_ss)
            # time_list.append(solution.Max(time_var))  
            # time_ss = []  
            time_var = time_dimension.CumulVar(index)
            total_time += solution.Min(time_var)
            
            plan_output +="Place {0:>2} Arrive at {2:>2}sec \n\n".format(manager.IndexToNode(index), route_load,(solution.Min(time_var)),solution.Max(time_var))
            
            # route output
            plan_output += 'Load of the route: {}\n'.format(route_load)
            plan_output += 'Time of the route: {}sec\n'.format(solution.Min(time_var))
            plan_output += "--------------------"
            
            #print(l1)
            time_ss.append([manager.IndexToNode(index),solution.Max(time_var),route_load])
            # time_list[vehicle_id]=time_ss
            time_ss=[]
            # output_list.append(-1)
            print(plan_output)
            total_load += route_load

        print('Total load of all routes: {}'.format(total_load))
        print('Total time of all routes: {}sec'.format(total_time))
      

        
    def main2():
        """Solve the VRP with time windows."""
        # Instantiate the data problem.
        # time_windows = create_time_windows()
        # num_vehicles = vehicles_number()
        # demands = read_demands()
        # vehicle_capacities = delivery_capacity()
        data = create_data_model(time_matrix1, time_windows, num_vehicles, demands, vehicle_capacities, depot_index)
        # Create the routing index manager.
        manager = pywrapcp.RoutingIndexManager(len(data['time_matrix']),
                                               data['num_vehicles'], data['depot'])

        # Create Routing Model.
        routing = pywrapcp.RoutingModel(manager)


        # Create and register a transit callback.
        def time_callback(from_index, to_index):
            """Returns the travel time between the two nodes."""
            # Convert from routing variable Index to time matrix NodeIndex.
            from_node = manager.IndexToNode(from_index)
            to_node = manager.IndexToNode(to_index)
            return data['time_matrix'][from_node][to_node]

        transit_callback_index = routing.RegisterTransitCallback(time_callback)

        # Define cost of each arc.
        routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)
        
        # Add Capacity constraint.
        def demand_callback(from_index):
            """Returns the demand of the node."""
            # Convert from routing variable Index to demands NodeIndex.
            from_node = manager.IndexToNode(from_index)
            return data['demands'][from_node]

        demand_callback_index = routing.RegisterUnaryTransitCallback(
            demand_callback)
        routing.AddDimensionWithVehicleCapacity(
            demand_callback_index,
            0,  # null capacity slack
            data['vehicle_capacities'],  # vehicle maximum capacities
            False,  # start cumul to zero
            'Capacity')
        penalty = 1000
        for node in range(1, len(data['time_matrix'])):
            routing.AddDisjunction([manager.NodeToIndex(node)], penalty)
        
        # Add Time Windows constraint.
        time = 'Time'
        routing.AddDimension(
            transit_callback_index,
            0,  # allow waiting time
            360*60,  # maximum time per vehicle
            False,  # Don't force start cumul to zero.
            time)
        time_dimension = routing.GetDimensionOrDie(time)
        
        # Add time window constraints for each location except depot.
        for location_idx, time_window in enumerate(data['time_windows']):
            if location_idx == 0:
                continue
            index = manager.NodeToIndex(location_idx)
            time_dimension.CumulVar(index).SetRange(time_window[0], time_window[1])

        # Add time window constraints for each vehicle start node.
        for vehicle_id in range(data['num_vehicles']):
            index = routing.Start(vehicle_id)
            time_dimension.CumulVar(index).SetRange(data['time_windows'][0][0],
                                                    data['time_windows'][0][1])

        # Instantiate route start and end times to produce feasible times.
        for i in range(data['num_vehicles']):
            routing.AddVariableMinimizedByFinalizer(
                time_dimension.CumulVar(routing.Start(i)))
            routing.AddVariableMinimizedByFinalizer(
                time_dimension.CumulVar(routing.End(i)))

        # Setting first solution heuristic.
        search_parameters = pywrapcp.DefaultRoutingSearchParameters()
        search_parameters.first_solution_strategy = (
            routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)
        search_parameters.time_limit.seconds = time_limit_seconds
        search_parameters.local_search_metaheuristic =(
        routing_enums_pb2.LocalSearchMetaheuristic.AUTOMATIC)
        search_parameters.time_limit.seconds = time_limit_seconds
        
        # Solve the problem.
        solution = routing.SolveWithParameters(search_parameters)
        # Print solution on console.
        if solution:
            print_solution(data, manager, routing, solution)
        return solution
    solution = main2()
  def route_carry_forward(initial_route_of_delivery):
     index=0
     maxload_per_rider=[]
     updated_initial_route_of_delivery={}
     for key,value in dict(initial_route_of_delivery).items():
       if(value!=[[0, 0, 0], [0, 0, 0]]):
         updated_initial_route_of_delivery.update({index:value})
         maxload_per_rider.append(value[len(value)-1][2])
         index+=1
     for key,value in dict(updated_initial_route_of_delivery).items():
       for i in value:
         i[2]=maxload_per_rider[key]-i[2]
     return updated_initial_route_of_delivery,maxload_per_rider

  def create_final_route(updated_initial_route_of_delivery):
     final_route_of_delivery={}
     for key, value in dict(updated_initial_route_of_delivery).items():
       temp_outer_list = []
       for small_list in value:
         temp_inner_list = []
         for i in small_list:
           temp_inner_list.append(i)
         temp_outer_list.append(temp_inner_list)
       final_route_of_delivery[key] = temp_outer_list
       print(final_route_of_delivery)
     return final_route_of_delivery

  def update_final_route(final_route_of_delivery,maxload_per_rider,awb,add,latitude_delivery,longitude_delivery):
    for key,value in dict(final_route_of_delivery).items():
      for j in value:
        # j[2]=maxload_per_rider
        j.append(awb[j[0]])
        j.append(add[j[0]])
        j.append(latitude_delivery[j[0]])
        j.append(longitude_delivery[j[0]])
    return final_route_of_delivery

  def create_delivery_csv(final_route_of_delivery): 
    for key,value in dict(final_route_of_delivery).items():
      Nodes=[]
      Time=[]
      Load=[]
      Address=[]
      AWB_NO=[]
      latitude=[]
      longitude=[]
      for j in value:
        Nodes.append(j[0])
        Time.append(j[1])
        Load.append(j[2])
        Address.append(j[4])
        AWB_NO.append(j[3])
        latitude.append(j[5])
        longitude.append(j[6])
      initial_dict = {'Nodes': Nodes, 'Time': Time, 'Load': Load,'AWB_NO':AWB_NO,'Address':Address,'latitude':latitude,'longitude':longitude}  
      df = pd.DataFrame(initial_dict)
      df.to_csv(f'Initial_Driver {key}.csv')


  delivery_add,add,awb,datalistd,latitude_delivery,longitude_delivery=read_address(delivery_addlink)
  time_matrix=create_time_matrix(latitude_delivery,longitude_delivery)
  time_windows=create_time_windows(delivery_add)
  demands=read_demands(delivery_demandslink)
  # np.random.seed(101)
  # demands = np.random.randint(27,32000,size= (215))
  # demands[0] = 0
  
  num_vehicles=vehicles_number(delivery_add)
  vehicle_capacities=delivery_capacity(num_vehicles)
  initial_route_of_delivery={}
  # delivery_vrp(time_matrix,initial_route_of_delivery)
  depot_index=0


  delivery_vrp(time_matrix,initial_route_of_delivery,time_windows,num_vehicles,demands,vehicle_capacities,depot_index)

  updated_initial_route_of_delivery,maxload_per_rider=route_carry_forward(initial_route_of_delivery)
  print(maxload_per_rider)
  final_route_of_delivery=create_final_route( updated_initial_route_of_delivery)
  final_route_of_delivery=update_final_route(final_route_of_delivery,maxload_per_rider,awb,add,latitude_delivery,longitude_delivery)
  create_delivery_csv(final_route_of_delivery)
  print(delivery_add)
  print(add)
  print(awb)
  print(datalistd)
  print(latitude_delivery)       
  print(longitude_delivery)
  print(demands)
  print(time_matrix)
  print(initial_route_of_delivery)
  print(maxload_per_rider)
  print(final_route_of_delivery)
  print(updated_initial_route_of_delivery)
  return initial_route_of_delivery,updated_initial_route_of_delivery,add,awb

APIKEY="AIzaSyCtfZjJ6cJO1EkdIpDSX_o1CPELWV456Sc"
initial_route_of_delivery,updated_initial_route_of_delivery,add,awb=delivery("/content/bangalore dispatch address (1).csv",APIKEY)

print(initial_route_of_delivery)
print(add)
print(awb)
print(updated_initial_route_of_delivery)

# print(delivery_add)
# print(add)
# print(awb)
# print(datalistd)
# print(latitude_delivery)       
# print(longitude_delivery)
# print(time_matrix1)
# print(time_list)
# print(initial_route_of_delivery)
# print(maxload_per_rider)
# print(final_route_of_delivery)
# print(updated_initial_route_of_delivery)

# # import pandas as pd
API_KEY = 'AIzaSyCtfZjJ6cJO1EkdIpDSX_o1CPELWV456Sc' 
pickup_demand_link="/content/7_pickup_demand.csv"
pickup_add_link="/content/7_pickup.csv"
# # delivery_addlink="/content/delivery_add_mocktest.csv"
# updated_initial_route_of_delivery={0: [[0, 0, 0], [0, 0, 0]], 1: [[0, 0, 0], [0, 0, 0]], 2: [[0, 0, 0], [0, 0, 0]], 3: [[0, 0, 0], [0, 0, 0]], 4: [[0, 0, 595273], [147, 1392, 564700], [126, 1392, 537340], [127, 1419, 514280], [118, 1456, 511786], [114, 1496, 488724], [125, 1605, 458751], [130, 1605, 458092], [134, 1712, 428266], [146, 1752, 419596], [138, 1752, 409258], [121, 1758, 387900], [137, 1760, 359859], [122, 1773, 328772], [132, 1802, 322339], [117, 1938, 292138], [124, 1963, 280321], [120, 2024, 276195], [143, 2073, 274469], [129, 2073, 243525], [136, 2167, 237125], [100, 2201, 225148], [116, 2239, 221424], [149, 3502, 211720], [150, 3538, 191167], [165, 3563, 179493], [162, 3563, 168691], [158, 3563, 140867], [156, 3563, 111371], [151, 3603, 81005], [157, 3766, 65148], [145, 4740, 62847], [191, 5119, 40371], [106, 6191, 31131], [109, 6205, 21486], [51, 6707, 0], [0, 7476, 0]], 5: [[0, 0, 586847], [5, 270, 569837], [13, 346, 548394], [48, 354, 518407], [4, 419, 512685], [22, 423, 481898], [50, 1035, 478123], [78, 1489, 468417], [56, 1720, 451100], [212, 2160, 447437], [172, 2287, 437165], [173, 2329, 434785], [205, 2523, 425957], [169, 2584, 416950], [198, 2592, 407422], [207, 2646, 383039], [175, 2739, 380747], [183, 2741, 375970], [204, 2786, 371034], [192, 2794, 340007], [203, 2924, 311089], [184, 2924, 291223], [209, 3013, 277206], [168, 3363, 251892], [164, 4374, 242395], [159, 4374, 237894], [152, 4561, 211709], [148, 4601, 204585], [155, 4601, 173848], [160, 4601, 167656], [163, 4601, 152034], [153, 4704, 120779], [154, 4782, 118731], [161, 5059, 97759], [123, 6387, 96405], [9, 6455, 79021], [45, 7405, 52891], [37, 7405, 47106], [39, 7405, 31643], [43, 7642, 0], [0, 7856, 0]], 6: [[0, 0, 614777], [34, 236, 586262], [23, 378, 586186], [92, 1243, 568475], [61, 1243, 545170], [52, 1243, 525588], [70, 1328, 520953], [64, 1341, 515404], [66, 1356, 497642], [93, 1364, 478260], [85, 1388, 459303], [60, 1688, 443622], [200, 2163, 420758], [206, 2251, 418787], [186, 2321, 401521], [208, 2425, 369752], [179, 2515, 356055], [177, 2515, 335466], [213, 2515, 325132], [201, 2535, 297062], [171, 2535, 272512], [170, 2535, 265802], [180, 2551, 264108], [202, 2587, 239465], [182, 2690, 228303], [188, 2690, 215735], [214, 2690, 190321], [176, 2722, 179351], [181, 2741, 156100], [178, 2746, 145244], [197, 2761, 125970], [185, 2781, 108998], [190, 2781, 90620], [189, 2788, 87124], [193, 2800, 80549], [196, 2818, 75598], [187, 2818, 73471], [195, 2960, 63536], [199, 3077, 47321], [210, 3275, 24117], [194, 3275, 2650], [12, 5515, 0], [0, 5694, 0]], 7: [[0, 0, 622778], [14, 433, 594346], [16, 453, 581299], [15, 500, 574812], [89, 1376, 561998], [97, 1379, 551961], [72, 1421, 547476], [95, 1470, 529187], [88, 1470, 501502], [73, 1470, 496215], [59, 1474, 467925], [90, 1479, 441342], [94, 1484, 437467], [83, 1484, 405828], [98, 1491, 379702], [77, 1491, 349992], [86, 1498, 320874], [81, 1506, 306871], [80, 1506, 298687], [76, 1506, 280025], [62, 1506, 276597], [67, 1520, 261619], [87, 1589, 254906], [57, 1664, 254443], [84, 1716, 250641], [79, 1746, 244629], [82, 1827, 221398], [99, 1834, 209252], [75, 1861, 179793], [68, 1877, 160423], [96, 1891, 149778], [65, 1934, 146176], [53, 1959, 142793], [63, 1972, 118778], [74, 2054, 108238], [91, 2062, 94284], [69, 2122, 78597], [55, 2134, 71907], [54, 2221, 50569], [71, 2764, 38650], [28, 3026, 17772], [2, 3264, 0], [0, 3462, 0]], 8: [[0, 0, 528977], [24, 211, 498403], [3, 239, 490370], [1, 239, 472412], [26, 268, 446279], [44, 284, 423619], [20, 353, 398108], [10, 416, 376025], [166, 579, 358496], [167, 579, 331489], [30, 657, 312147], [211, 1047, 282299], [141, 1790, 256428], [139, 1804, 247852], [142, 1949, 231546], [140, 2003, 219291], [115, 2095, 202486], [103, 2456, 199670], [101, 2540, 187308], [113, 2574, 186374], [144, 2578, 183068], [111, 2591, 166418], [135, 2597, 150012], [102, 2620, 146987], [131, 2627, 137821], [119, 2640, 108582], [104, 2648, 81717], [110, 2654, 71904], [128, 2654, 47369], [107, 2656, 29249], [105, 2673, 15773], [108, 2701, 0], [0, 3929, 0]], 9: [[0, 0, 409075], [174, 120, 389634], [31, 437, 371116], [32, 529, 349167], [21, 600, 328183], [42, 632, 319621], [49, 687, 311852], [25, 752, 298914], [8, 870, 278424], [29, 919, 276448], [17, 1030, 254213], [18, 1055, 234620], [35, 1093, 216936], [36, 1093, 198202], [38, 1093, 186005], [46, 1093, 174257], [41, 1104, 143915], [7, 1140, 131525], [47, 1157, 125115], [33, 1208, 115316], [27, 1208, 88529], [6, 1257, 65977], [19, 1263, 42393], [11, 1263, 20218], [40, 1310, 0], [0, 1496, 0]]}
# add=['6, Shakambari Nagar, 1st stage, JP Nagar, Bangalore', '1, 24th Main Rd, 1st Phase, Girinagar, KR Layout, Muneshwara T-Block, JP Nagar, Bangalore', '954, 2nd Floor, 24th Main, 2nd Phase, Opposite LIC Building, JP Nagar, Bangalore', '1, 24th Main Rd, 1st Phase, Girinagar, KR Layout, Muneshwara T-Block, JP Nagar, Bangalore', '67, 15th Cross, 6th B Main, JP Nagar, Bangalore', '281, 2nd Floor, 15th Cross, 5th Phase, JP Nagar, Bangalore', 'Cross Roads Inn, 827, Near RV Dental College Compound, 24th Main, 12th Cross, JP Nagar, Bangalore', '21, 24th Main Road, 6th Phase, JP Nagar, Bangalore', '99/4, Nataraja Layout, 7th Phase, JP Nagar, Bangalore', 'No.72, 2nd Floor 100 Feet Road, next to Max & Crossword, 3rd Phase, J. P. Nagar, Bengaluru', 'Eden Park7, 8 Doresani Palya, Near Kalyani Magnum, Opposite Oracle, 5th Phase, JP Nagar, Bangalore', 'Amoolya, 1st Floor, 24th Main, 6th Phase, JP Nagar, Bangalore', '47/1, 9th Main,1st Cross, Miniforest, Phase 3, JP Nagar, Bangalore', 'The HHI Select Bengaluru Hotel, 686, 15th Cross, Ring Road, 2nd Phase, JP Nagar, Bangalore', 'Quality Inn - Shravanthi, 60, 13th Cross, 2nd Main, 3rd Phase, JP Nagar, Bangalore', '5th Cross Road, Dollar Layout, 3rd Phase, JP Nagar, Bangalore', '57, 15th Cross Road, Outer Ring Road, Phase 6, JP Nagar, Bangalore', '97, Wilson Garden Housing Society, 7th Phase, JP Nagar, Bangalore', '44-45, Terrace Floor, 24th Main Road, 7th phase, JP Nagar, Bangalore', 'Amoolya, 1st Floor, 24th Main, 6th Phase, JP Nagar, Bangalore', '8, 15th Main, 5th Phase, JP Nagar, Bangalore', '114, Kothanur Main Road, Santrupthi Nagar, 7th Phase, JP Nagar, Bangalore', 'Site 15, 15th Cross, 100 Feet Road, 4th Phase, JP Nagar, Bangalore', '204, 4th Cross, KSRTC Layout, 2nd Phase, JP Nagar, Bangalore', '18, K.R Layout, Dollar Colony, 4th Phase, JP Nagar', 'Someshwara Bhavan, RBI Layout, 7th Phase, Kothnur Main Road, JP Nagar, Bangalore', '10/3, Shamanna Garden, 22nd Main Rd, Phase 5, JP Nagar, Bangalore', '296, Ground Floor, 5th Phase, 100 ft Outer Ring Road, JP Nagar, Bangalore', '46/A, 1st Main, 3rd Phase, JP Nagar, Bangalore', 'Brigade Millenium Inside Indian Music Experience Museum, JP Nagar, Bangalore, Bengaluru', '81, 7th Main, 5th Cross, Bank of Baroda Colony, 7th Phase, JP Nagar, Bangalore', 'JP Nagar, Phase 7, Bangalore', '724, 3rd Floor, RBI Layout, Rini Pearl, Opposite E.K. Retail, 7th Phase, JP Nagar, Bangalore', '305, Anand NR Onyx, 15th Cross, 100 Feet Ring Road, 5th Phase Extension, JP Nagar, Bangalore', '104/1, 21st Main Road, 6th Cross Road, R K Colony, JP Nagar 2nd Phase, Bangalore', "1260 SY 35/4 SJR Tower's, 24th Main Puttanhalli, 7th Phase, JP Nagar Bangalore", "1260 SY 35/4 SJR Tower's, 24th Main Puttanhalli, JP Nagar 7th Phase, Bangalore", '1260, SY 35/4, SJR Towers, 24th Main Puttanhalli, 7th Phase, JP Nagar, Bangalore', "1260 SY 35/4 SJR Tower's, JP Nagar 7th Phase, 24th Main Puttanhalli, JP Nagar, Bangalore", '1260, SY 35/4, SJR Towers, 24th Main Puttanhalli, 7th Phase, JP Nagar, Bangalore', '5th A Cross, Lakshmi Complex, Manjunatha Colony, Near RV Dental College, 2nd phase, JP Nagar, Bangalore', '35/4, 24th main JP Nagar 7th phase, Puttenahalli, JP Nagar, Bangalore', '99/2A, Kothnoor Main Road, Opposite RBI Layout Bus Stop, 7th Phase, JP Nagar, Bangalore', '77/1, 24th Main, 2nd Phase, JP Nagar, Bangalore', '18th Cross road, 5th Phase, JP Nagar, Bangalore', "1260, SY 35/4, SJR Tower's, 7th Phase, 24th Main Puttanhalli, JP Nagar, Bangalore", "1260 SY 35/4 SJR Tower's, JP Nagar 7th Phase, 24th Main Puttanhalli, JP Nagar, Bangalore", 'Shop 1, 129, 24th Main, 5th Phase, JP Nagar, Bangalore', '311, 15th Cross, 5th Phase, JP Nagar, Bangalore', 'Big Bazzar Building, JP Nagar, Bangalore', '15, 7th Cross, Near Mother Teresa School, ITI Layout, Hosapalya Main Road, HSR, Bangalore', '119/19, Ground Floor, 10th Cross, Venkateshwara Layout, SG Palya, HSR, Bangalore', '1554, Ground Floor, 19th Main, Sector 1, HSR, Bangalore', '7th Cross, Sector 1, HSR, Bangalore', '27th Main road, Sriven Teesta, Near Raymond?s Showroom HSR, Bangalore', '2331, 17th Cross, 24th Main, HSR, Bangalore', 'Shop 5, LNR Building, Harlur Road, HSR, Bangalore', '64,65, 27th Main Road, Sector 1, HSR Layout', '27th Main, Near NIFT, Sector-1, HSR, Bangalore', '2318, 27th Main Road, 1st Sector, HSR, Bangalore', '569/4, Sector 1, HSR, Bangalore', '1554, Ground Floor, 19th Main, Sector - 1, HSR, Bangalore', '2733, 16th Cross, 27th Main, Opposite NIFT, Sector 1, HSR Layout, Bangalore, HSR, Bangalore', '543, 7th Cross, 24th Main, Opposite Nous Info Systems, Sector 1, HSR, Bangalore', '13th Cross, 24th Main, Opposite Assetz Apartment, 1st Sector, HSR, Bangalore', '7th Cross Road, Agara Village, 1st Sector, HSR, Bangalore', '680-669, 13th Cross Rd, 1st Sector, HSR Layout, Bengaluru, Karnataka', '2724, 31st Main, 17th Cross, HSR, Bangalore', '1543, 7th Cross, 19th Main, 1st Sector, HSR, Bangalore', '1214, 17th Cross Road, Parangi Palaya, Sector 2, HSR Layout, Bangalore', 'Basement 2064, Siri Iris Building, 24th Main, N.R.T.A Enclave, HSR, Bangalore', '809/A, 27th Main, 100 Feet Road, 1st Sector, HSR, Bangalore', 'Building 2686, 31 Main, 13 Cross, Sector 1, Behind CPWD Quarters, HSR Layout, HSR, Bangalore', '191, Ground Floor, 27th Main Road, Near CPWD Quarters, Beside Lawrance & Mayo, Sector 2, HSR, Bangalore', '2633, 27th Main, 13th Cross, 1st Sector, Liss Arcade, HSR, Bangalore', '1548, 19th Main, Outer Ring Road, Opposite BMTC Bus Depot, HSR, Bangalore', '2733, 16th Cross, 27th Main Road, Oppsite, NIFT College, 1st Sector, HSR Layout, Bangalore', '2610, 27th Main, Near NIFT, HSR Layout, HSR, Bangalore', '1, 328, 27th Main, 21st Cross, Sector 2, HSR, Bangalore', '49, Agara Circle, Near Hanuman Statue, HSR Layout, HSR, Bangalore', 'Opposite NIFT College, 2733, 16th Cross, 27th Main Road, PWD Quarters, 1st Sector, HSR Layout, HSR, Bangalore', '2733, 16th Cross, 27th Main, Opppsite NIFT College, Sector 1, HSR, Bangalore', 'Next to Grigliato, Sector 1 , HSR Layout, HSR, Bangalore', '2606, Ground Floor, The Ambience Building, 16th Cross, 27th Main, Sector 1, HSR, Bangalore', '2802, 27th Main Road, Sector 1, HSR, Bangalore', '1562, Sector 1, HSR, Bangalore', '2738, 27th Main, Sector 1, HSR, Bangalore', '646, 12th Cross, 27th Main, Sector 1, HSR, Bangalore', '647, Ground Floor, 27th Main Road, Sector 1, HSR, Bangalore', '191, First Floor, 27th Main, Sector 2, HSR, Bangalore', '2317, 27th Main, Sector 1, Opposite NIFT College, HSR Layout, HSR, Bangalore', '2628, 27th Main Road, 1st Sector, HSR Layout, Bangalore, HSR, Bangalore', '1554, Ground Floor, 19th Main, Sector - 1, HSR, Bangalore', '780, 12th Cross, 19th Main, HSR, Bangalore', '2606, The Ambience, 27th Main Road, 16th cross, HSR Layout', '331, Ground Floor, 27th Main, 2nd Stage, HSR, Bangalore', '1548, 3rd Floor,19th Main Road, Sector 1, Agara Village, HSR, Bangalore', 'Shop 339, 27th Main Road, HSR Layout Sector 2, Bangalore', '2610, 27th Main, Near NIFT, HSR Layout, HSR, Bangalore', '1558, 19th Main, Ring Road, Near Indian Oil Petrol Bunk, Sector 1, HSR, Bangalore', '712, 6th Cross, 5th Main, Off 80 Feet Road, Indiranagar, Bangalore', '14, 2nd Floor, Church Street, Bangalore', 'First Floor, 14, Church Street, Bangalore', '36, Off MG Road, Church Street, Bangalore', '42, Church Street, Bangalore', '33, High Gates Hotel, Church Street, Bangalore', '2, Church Street, Bangalore', '46, Church Street, Bangalore', '9/3, Prestige Pearl House, Museum Road, Church Street, Bangalore', '1A, Church Street, Bangalore', 'G-005, City Centre, 28/4, Church Street, Bangalore', '22, Amoeba Complex, Church Street, Bangalore', 'Church Street', '24, Church Street, Bangalore', '765, 1st Floor, 1st Main, Domlur Layout, Domlur, Bangalore', '8/ 9, 17th F Cross, 2nd Stage, Indiranagar, Bengaluru', 'Next to CMH Metro Station, CMH Road, Indiranagar, Bangalore', 'Ground Floor, Sri Shiva Sai Complex, 13th Cross, 7th Main, 2nd Stage, HAL, Off Double Road, Indiranagar, Bangalore', 'Domlur, Bangalore', '46, Church Street, Bangalore', 'Shop 6, First Floor, Binnamangala First Stage, Indiranagar, Bangalore', '970, 12th Main, 5th Cross, Indiranagar, Bangalore', '1088, 12th Main, HAL 2nd Stage, Off 100 Feet Road, Indiranagar, Bangalore', '181, 3rd Floor, Amar Jyothi Layout, Inner Ring Road, Domlur, Bangalore', '544, First Floor, Near Indiranagar Metro Station, CMH Road, Indiranagar, Bangalore', '212/A, 1st Main Road, Stage 2, Indiranagar, Bangalore', '598, 1st floor, 1st Cross, 1st A Main Road, Domlur Layout, 1st Stage, Domlur, Bangalore', '197/A, Double Road, 2nd Stage, Opposite HDFC Bank, Indiranagar, Bangalore', 'G-005, City Centre, 28/4, Church Street, Bangalore', "4, 39/1, St Mary's Building, 2nd Stage, Indiranagar, Bangalore", '212/A, 1st Main Road, Stage 2, Indiranagar, Bangalore', '48, Triumph Towers, Church Street, Bangalore', 'Srinivasan Towers, ESI Hospital Road, Off Double Road, Indiranagar, Bangalore', "Number 4 St Mary's Building, 39/1, 2nd Stage, Indiranagar, Bangalore", '949, Ground Floor, HAL 2nd Stage, 12th Main, 100 feet Road, Indiranagar, Bangalore', '50/1, Haridevpur, Shantala Nagar, Ashok Nagar, Church Street, Bangalore', '1324, Double Road, 2nd Stage, Opposite Cauvery School, Indiranagar, Bangalore', '1083, 12th main, 5th Cross, Indiranagar, Bangalore', '949, 12th Main, Ground Floor, Off 100 Feet Road, Indiranagar, Bangalore', '2nd Stage, Indiranagar, Bangalore', '3217, 13th Cross, Indiranagar, Bangalore', '12th Main, HAL 2nd Stage, ESI To Domlur, Service Road, Indiranagar, Bangalore', '12th Main Road Junction, Double Road, Indiranagar, Bangalore', "4, St Mary's Building, 2nd Stage, Indiranagar, Bangalore", '46/1, Cobalt Building, Church Street, Bangalore', '39/7, 5th Cross, 6th Main, Appareddy Palya, Indiranagar, Bangalore', '949, 12th Main Rd, Appareddipalya, Indiranagar, Bengaluru, Karnataka', '598, 1st Floor, 1st Cross, 1st A Main Road, Domlur Layout, 1st Stage, Domlur, Bangalore', '2/1 Unit 6, Hoodi Kodigehalli Road, Opposite Crystal Apartment, KR Puram, Bangalore', '39, Aiyaapanagar Main Road, Near Krishna Community Hall, KR Puram, Bangalore', '92, Kodigehalli Main Road, Ayyappa Nagar, KR Puram, Bangalore', 'Devasandra Main Road, Ayyappa Nagar, KR Puram, Bangalore', '92, Ground Floor, Muninanjappa Gardens, Kodigehalli Main Road, KR Puram, Bangalore', 'Coconut Garden Layout, Kodigehalli Main Road, KR Puram, Bangalore', '21/28, Radhakrishna Nilaya, Opp SEA Institutions, Ayappa Nagar, KR Puram, Bangalore', '2/1 Unit 6, Hoodi Kodigehalli Road, Opposite Crystal Apartment, KR Puram, Bangalore', '7, Anurhh Arcade, Hoodi Road, Kodigehalli Road, KR Puram, Bangalore', '76, Shruthi Layout, Basavanapura Main Road, KR Puram, Bangalore', '7, Anurhh Arcade, Hoodi Road, Kodigehalli Road, KR Puram, Bangalore', 'Shop 2, Kodigahalli Main Road, KR Puram', '2/1 Unit 6, Hoodi Kodigehalli Road, Opposite Crystal Apartment, KR Puram, Bangalore', '44, Kodigehalli to Hoodi Main Road, Mahadevapura Post, KR Puram, Bangalore', '7, Anurhh Arcade, Hoodi Road, Kodigehalli Road, KR Puram, Bangalore', '2/1 Unit 6, Hoodi Kodigehalli Road, Opposite Crystal Apartment, KR Puram, Bangalore', 'Shop 2, Kodigahalli Main Road, KR Puram', '7, Anurhh Arcade, Hoodi Road, Kodigehalli Road, KR Puram, Bangalore', 'Near Bank Of India ATM, Ramka Colony, Bilekahalli, Marathahalli, Bangalore', 'Near Bank Of India ATM, Ramka Colony, Bilekahalli, Marathahalli, Bangalore', '595, Ground Floor, Kundalahalli, Varthur Hobli Mahadevpura, Marathahalli, Bangalore', '20/7, Swamy Legato, Outer Ring Road, Kadubeesanahalli, Marathahalli, Bangalore', '20\\5, Panathur Junction, Outer Ring Road, Kadubeessanahalli, Marathahalli, Bangalore', '20/5, 1st Floor, Panathur Junction, Outer Ring Road, Marathahalli, Bangalore', 'Ibis Bengaluru, Opposite RMZ Ecospace Business Park, Sarjapur Outer Ring Road, Marathahalli, Bangalore', '10/3, Devarabeesanahali, Outer Ring Road, Opposite Embassy Tech Park, Marathahalli, Bangalore', 'Shop 37, 3rd Cross, Outer Ring Road, Kadubisnahalli, Marathahalli, Bangalore', '2nd Floor, All Season Super Market Building, Panathur Road, Kadubeesanahalli, Panathur, Marathahalli, Bangalore', '89/1, Tulasi Theater Road, Near SBR Palace, Marathahalli, Bangalore', '20/5, Narayanswamy Building, Kadubeesanahalli Bridge, Outer Ring Road, Kadubeesanahalli, Marathahalli, Bangalore', '90/4, Above Sony Centre, Opposite Park Plaza, Outer Ring Road, Marathahalli, Bangalore', 'Kadubeesanahalli, Near Aricent Technologies, Marathahalli, Bangalore', '94/2, Panathur Railway Station Road, Opp to JP Morgan (Outer Ring Road), Munnireddy Layout, Panathur, Bangalore', '89/1, Service Road, Marathahalli, Bangalore', '88, KBR Complex, More Mega Store, Marathahalli, Bangalore', 'Panathur Main Road, Kadubeesanahalli, Marathahalli, Bangalore', '127, Kadubisannhalli, Panathur Main Road, Marathahalli, Bangalore', 'Ground Floor, Vims Hospital Buidling, Opposite to More, Marathahalli, Bangalore', '77 Town Center, Yemalur Road, Marathahalli Village, Marathahalli, Bangalore', 'Near Madurai Idly, SGR Dental College Road, CKB Layout, Chandra Layout, Marathahalli, Bengalore', 'Ground Floor, More Megastore, Service Road, Marathahalli, Bangalore', '88, Outer Ring Road, Next To More Mega Store, Marathahalli, Bangalore', '88, 1st Floor, VIMS Hospital Building, Outer Ring Road, Marathahalli, Bangalore', 'Ikon Building, Next to Sony Centre, Outer Ring Road, Marathahalli', '3, Srinivasa Nilayam, Vidya Vikas School Road, Panathur New Extension, Kaverappa Layout, Marathahalli, Bangalore', 'First Floor, Raja Ikon, Opposite Hotel Radisson Blu, Near Marathahali Bridge, Marathahalli, Bangalore', 'Shop 217, 2nd main road, Kadubeesanahalli Croma, Back Side road Near Kumbeshwara Temple Marathahalli, Bangalore', '88, 3rd Floor, KBR Mall, Above More Mega Store, Outer Ring Road, Marathahalli, Bangalore', 'Near Madurai Idly, SGR Dental College Road, CKB Layout, Chandra Layout, Marathahalli, Bengalore', '1st Floor, NTR Royal Plaza, Outer Ring Road, Marathahalli, Bangalore', '20/5, Outer Ring Road, Kadubeesanahalli, Marathahalli, Bangalore', 'Kadubeesanahalli, Marathahalli Outer Ring Road, Opposite JP Morgan, Varthur Hobli, Marathahalli, Bangalore', 'Yemalur, Marathahalli, Bangalore', '20\\5, Panathur Junction, Outer Ring Road, Kadubeessanahalli, Marathahalli, Bangalore', 'Outer Ring Road, Opposite to JP Morgan, Kodbisanhalli, Marathahalli, Bangalore', 'Shop 7, 8 Opposite, Airtel Express, Panathur Main Road, Marathahalli, Bangalore', 'Srinivasa Nilayam, Site 3, Vidya Vikas School Road, Panathur New Extension, Kaverappa Layout, Marathahalli, Bangalore', 'Salarpuria Sattva Aura, Kiosk 6, Foodworks Food Court, Block 11, Marathahalli - Sarjapur Outer Ring Road, Kaverappa Layout, Kadubeesanahalli, Marathahalli, Bangalore', '23/4, Kariyammana Agrahara Road Kadubisinahalli, Prestige Tech Park Back Gate, Marathahalli, Bangalore', 'Plot 302, Shop 1, 2nd Cross, Kadubesanahalli, Panathur Main Road, Marathahalli, Bangalore', '6,Opposite Prestige Tech Park, Kadubeesanhalli Bus Stop, Marathahalli, Bangalore', '18, Prakruthi Enclave, Panathur Road, Kadubeesanahalli, Marathahalli, Bangalore', 'Shop 217, 2nd Main Road Kadubeesanahalli Croma Back Side Road Near Kumbeshwara Temple Marathahalli, Bangalore', '77 Town, Building No 3, Divya Shree Building, Yamalur Post, Marathahalli, Bangalore', 'Near kaka singh dhaba, RMZ eco world backgate', '41, Kadubeesanahalli, Marathahalli, Bangalore', '5, KBR Mall Complex, Ground Floor, More Mega Store, Varthur Hobli, Marathahalli, Bangalore']
# [62201852038, 73350066683, 60104333056, 49726345575, 33178947349, 76031744666, 81926175607, 27632908686, 66314622688, 83288941747, 36774055970, 49180403091, 65307617155, 32162999926, 67841310375, 98072567575, 81028594970, 72346908029, 73908465584, 82980897770, 72031214940, 13346207178, 66193906105, 18834198685, 77357637627, 50570222462, 86868052143, 60270106051, 61686659900, 69289578038, 71217404672, 24549099395, 50581824353, 52273090335, 60730226124, 38777880457, 14876577908, 15743308603, 96594637899, 75423501902, 13385067871, 25281194232, 60615787248, 85830764356, 87207515803, 62376246282, 34763837898, 95782788535, 92874070081, 28090773455, 65216540873, 30262250302, 95752660397, 30449400919, 52917061849, 41474085570, 74962568491, 33783112676, 40837739535, 42498449819, 14699928469, 54163870135, 98967476662, 94332983235, 21104565365, 78472305957, 11910424508, 89394948450, 87898682349, 71466613736, 58089927559, 85539430303, 85984892588, 53402748741, 49002247401, 29805721561, 84618864102, 50745703670, 89111417547, 56766768595, 85469796479, 31316164825, 18227945733, 94402524628, 46205581478, 22921695090, 91311238475, 89040589151, 96874607527, 17354068059, 76687493477, 50915970151, 19365687734, 20687322207, 47082143365, 81727476606, 28764133976, 66471762239, 28074155949, 39213602287, 21225161006, 15239382796, 99015056791, 44759282449, 52059909281, 76893410434, 84366653069, 41965274833, 40661403008, 59997033261, 83381832974, 98170732794, 69379883919, 70918939146, 81721151401, 29925333677, 46767096463, 92941598133, 86841663173, 24472334890, 26105795180, 94667742985, 38434272738, 53198547414, 38200322788, 47003637195, 85725180680, 70899793952, 61422999142, 55525210263, 13337031353, 73796529420, 55217454663, 38653109135, 77604849495, 75568022308, 81655937477, 20550226542, 62399381626, 91477551055, 66146763539, 84612864961, 75506986031, 62280811516, 81065467193, 79226518761, 65665446450, 96249705883, 80856836359, 63269771781, 81129879069, 28529174781, 62724763094, 62644046092, 17432534499, 84273793675, 60381594139, 61354798733, 60559333974, 89948676925, 44140764186, 34795550625, 81037487822, 47626343441, 84014569034, 15145909184, 35496906287, 47772983315, 25842170396, 60147650973, 84961010116, 19783328541, 22195593543, 86439214657, 48712626536, 79263517463, 98486281871, 48552195740, 51656603551, 19455702296, 98312518779, 55026656606, 73406214406, 47015403024, 45180804640, 31203804545, 66199582549, 16213830807, 13002857017, 15691083877, 62758300340, 54016008457, 43727711975, 24526739732, 72580152196, 34889886477, 65188908427, 18924249557, 49862610786, 56516948976, 12358732625, 22660986194, 25907907008, 61450912280, 60841023934, 35828962763, 87093968225, 71791751983, 75026092650, 41891691354, 49695767650, 62165843566, 70987447117, 17162566322, 32184021928]
# awb=[62201852038, 73350066683, 60104333056, 49726345575, 33178947349, 76031744666, 81926175607, 27632908686, 66314622688, 83288941747, 36774055970, 49180403091, 65307617155, 32162999926, 67841310375, 98072567575, 81028594970, 72346908029, 73908465584, 82980897770, 72031214940, 13346207178, 66193906105, 18834198685, 77357637627, 50570222462, 86868052143, 60270106051, 61686659900, 69289578038, 71217404672, 24549099395, 50581824353, 52273090335, 60730226124, 38777880457, 14876577908, 15743308603, 96594637899, 75423501902, 13385067871, 25281194232, 60615787248, 85830764356, 87207515803, 62376246282, 34763837898, 95782788535, 92874070081, 28090773455, 65216540873, 30262250302, 95752660397, 30449400919, 52917061849, 41474085570, 74962568491, 33783112676, 40837739535, 42498449819, 14699928469, 54163870135, 98967476662, 94332983235, 21104565365, 78472305957, 11910424508, 89394948450, 87898682349, 71466613736, 58089927559, 85539430303, 85984892588, 53402748741, 49002247401, 29805721561, 84618864102, 50745703670, 89111417547, 56766768595, 85469796479, 31316164825, 18227945733, 94402524628, 46205581478, 22921695090, 91311238475, 89040589151, 96874607527, 17354068059, 76687493477, 50915970151, 19365687734, 20687322207, 47082143365, 81727476606, 28764133976, 66471762239, 28074155949, 39213602287, 21225161006, 15239382796, 99015056791, 44759282449, 52059909281, 76893410434, 84366653069, 41965274833, 40661403008, 59997033261, 83381832974, 98170732794, 69379883919, 70918939146, 81721151401, 29925333677, 46767096463, 92941598133, 86841663173, 24472334890, 26105795180, 94667742985, 38434272738, 53198547414, 38200322788, 47003637195, 85725180680, 70899793952, 61422999142, 55525210263, 13337031353, 73796529420, 55217454663, 38653109135, 77604849495, 75568022308, 81655937477, 20550226542, 62399381626, 91477551055, 66146763539, 84612864961, 75506986031, 62280811516, 81065467193, 79226518761, 65665446450, 96249705883, 80856836359, 63269771781, 81129879069, 28529174781, 62724763094, 62644046092, 17432534499, 84273793675, 60381594139, 61354798733, 60559333974, 89948676925, 44140764186, 34795550625, 81037487822, 47626343441, 84014569034, 15145909184, 35496906287, 47772983315, 25842170396, 60147650973, 84961010116, 19783328541, 22195593543, 86439214657, 48712626536, 79263517463, 98486281871, 48552195740, 51656603551, 19455702296, 98312518779, 55026656606, 73406214406, 47015403024, 45180804640, 31203804545, 66199582549, 16213830807, 13002857017, 15691083877, 62758300340, 54016008457, 43727711975, 24526739732, 72580152196, 34889886477, 65188908427, 18924249557, 49862610786, 56516948976, 12358732625, 22660986194, 25907907008, 61450912280, 60841023934, 35828962763, 87093968225, 71791751983, 75026092650, 41891691354, 49695767650, 62165843566, 70987447117, 17162566322, 32184021928]
# # add=["1260 SY 35/4 SJR Tower's, 24th Main Puttanhalli, JP Nagar 7th Phase, Bangalore", '2318, Sector 1, Near NIFT College, HSR, Bangalore', '68, Appareddy Palya, Near ESI Hospital, HAL 2nd Stage, Double Road, Indiranagar, Bangalore']
# # awb=[62201852038, 73350066683, 60104333056]
# # updated_initial_route_of_delivery={0: [[0, 0, 138000], [1, 1817, 60000], [2, 3551, 0], [0, 6073, 0]]}
# # delivery_add=["1260+SY+35/4+SJR+Tower's,+24th+Main+Puttanhalli,+JP+Nagar+7th+Phase,+Bangalore", '2318,+Sector+1,+Near+NIFT+College,+HSR,+Bangalore', '68,+Appareddy+Palya,+Near+ESI+Hospital,+HAL+2nd+Stage,+Double+Road,+Indiranagar,+Bangalore']
# # pickup_add=[]
# # add=[]
# # awb=[]
# # adresses=[]
# # latitude_total=[]
# # longitude_total=[]
# # multi_depot=[]
# # multi_endhub=[]
# # demands_multidepot=[]
# # vehicle_capacitys=[]
# # time_windows_new=[]

def pickup(updated_initial_route_of_delivery,add,awb,pickup_add_link,pickup_demand_link,API_KEY):
  # time_list4={}
  

  def create_delivery_add(add):
    delivery_add=[]
    for i in add:
      i=i.replace(" ","+")
      delivery_add.append(i)
    return delivery_add
  # the previous data used 1st pickup (using few functions for 1st pickup)
  # not general
  def merge(pickup_add_link,add,awb):
    merge2add=[]
    merge2awb=[]
    dfp = pd.read_csv(pickup_add_link)
    merge2add= dfp['address'].to_list()
    merge2awb=dfp['AWB'].to_list()
    add=add+merge2add
    awb=awb+merge2awb
    # print(add,awb)
    return add,awb


  


  # general pickup
  def add_pickup(pickup_add_link):
    dfp = pd.read_csv(pickup_add_link)
    pickupadd_list= dfp['address'].to_list()
    for i in range(len(pickupadd_list)):
      pickupadd_list[i]=pickupadd_list[i].replace(" ","+")
    pickup_add=pickupadd_list
    # print(pickup_add)
    return pickup_add 

  #general pickup
  def pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery):
    list1=[]
    list2=[]
    time_listupdate=[]
    
    time_listupdate.append(0)
    
    list1.append(0)
    list2.append(0)
    for key,value in dict(updated_initial_route_of_delivery).items():
      for i in range (len(value)):
        if(i==len(value)-2):
          list1.append(value[i][0])
          list2.append(value[i][0])
          time_listupdate.append(value[i][1])
          # load_listupdate.append(value[i][2])
    # print(list1,list2,time_listupdate)
    return list1,list2,time_listupdate


    #general pickup
  def address(delivery_add,list1):
    # list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
    adresses=[]
    for i in list1:
      adresses.append(delivery_add[int(i)])
    # print(adresses)
    return adresses


  

  #general pickup
  def lat_long_pickup(add):
    latitude_total=[]
    longitude_total=[]
    for i in range(len(add)):
      r = requests.get('https://maps.googleapis.com/maps/api/geocode/json?address=' + add[i] +'&key=' + API_KEY)
      resp = json.loads(r.text)
      print(resp)
      lat = resp['results'][0]['geometry']['location']['lat']
      lon = resp['results'][0]['geometry']['location']['lng']
      latitude_total.append(lat)
      longitude_total.append(lon)
      # print(latitude_total,longitude_total)
    return latitude_total,longitude_total

  # #not general pickup
  def appending_list1_forpickup(pickup_add,list1,delivery_add):
    # list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
    size= len(delivery_add)
    for i in range(len(pickup_add)):
      list1.append(size+i)
    # print(list1)
    return list1
  def update_address(adresses,pickup_add):
    for i in pickup_add:
      adresses.append(i)
    return adresses

  def lat_long_pickup1(adresses):
    latitude_partial=[]
    longitude_partial=[]
    for i in range(len(adresses)):
      r = requests.get('https://maps.googleapis.com/maps/api/geocode/json?address=' + add[i] +'&key=' + API_KEY)
      resp = json.loads(r.text)
      lat = resp['results'][0]['geometry']['location']['lat']
      lon = resp['results'][0]['geometry']['location']['lng']
      latitude_partial.append(lat)
      longitude_partial.append(lon)
      # print(latitude_total,longitude_total)
    return latitude_partial,longitude_partial

  def time_calculator(lon1, lat1, lon2, lat2):
    lon1, lat1, lon2, lat2 = map(np.radians, [lon1, lat1, lon2, lat2])
    newlon = lon2 - lon1
    newlat = lat2 - lat1
    haver_formula = np.sin(newlat/2.0)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(newlon/2.0)**2
    dist = 2 * np.arcsin(np.sqrt(haver_formula ))
    m = 6367 * dist *1000
    time=m/6.11
    return int(math.floor(time))

  #general pickup
  def time_matrix(latitude_partial,longitude_partial):
    # def create_time_matrix(latitude_delivery,longitude_delivery):
    time_matrix = np.zeros((len(latitude_partial),len(longitude_partial)))
    for i in range(len(latitude_partial)):
      for j in range(len(longitude_partial)):
        # calculate the distance using the distance matrix function
        time_matrix[i, j] = time_calculator(longitude_partial[i], latitude_partial[i],longitude_partial[j],latitude_partial[j])
    return time_matrix
    
 #general pickup
  def multi_end_and_depot(list2):
  #  list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
   multi_depot=[]
   multi_endhub=[]
   for i in range(1,len(list2)):
     multi_depot.append(i)
   for i in range(len(multi_depot)):
     multi_endhub.append(0)   
  #  print(multi_depot,multi_endhub)
   return multi_depot,multi_endhub


  def pickup_demands(pickup_demand_link,multi_depot):
    # multi_depot,multi_endhub=multi_end_and_depot(updated_initial_route_of_delivery)
    demands_multidepot=[]
    demands_multidepot.append(0)
    for i in range(len(multi_depot)):
      demands_multidepot.append(0)
    pickupdemands_list=[]
    dfpd = pd.read_csv(pickup_demand_link)
    pickupdemands_list= dfpd['demand'].to_list()
    for i in pickupdemands_list:
      demands_multidepot.append(i)
    # print(demands_multidepot)
    return demands_multidepot

  def numvech_max_and_vehiclecap(list2):
    # list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
    num_vehiclemax=len(list2)-1
    vehicle_capacitys=[]
    for i in range(num_vehiclemax):
      vehicle_capacitys.append(640000)
    print(num_vehiclemax,vehicle_capacitys)
    return num_vehiclemax,vehicle_capacitys


  def creating_timewindow_new(pickup_add_link,time_listupdate):
    # list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
    time_windows_new=[]
    pickup_add=add_pickup(pickup_add_link)
    for i in range(len(time_listupdate)):
      time_windows_new.append((time_listupdate[i],300*60))
    for i in range(len(pickup_add)):
      time_windows_new.append((0,300*60))
    print(time_windows_new)
    return time_windows_new


  def pickup_vrp(time_windows_new,time_matrix2,multi_depot,multi_endhub,demands_multidepot,num_vehiclemax,vehicle_capacitys,time_list4):
    time_limit_seconds = 60 # time limit for calculation
    # time_windows_new=creating_timewindow_new(pickup_add_link,updated_initial_route_of_delivery)
    # time_matrix2=time_matrix(address)
    # multi_depot,multi_endhub=multi_end_and_depot(updated_initial_route_of_delivery)
    # demands_multidepot=pickup_demands(pickup_demand_link,updated_initial_route_of_delivery)
    # num_vehiclemax,vehicle_capacitys=numvech_max_and_vehiclecap(updated_initial_route_of_delivery)
    # time_list4={}
    # [START data_model]
    def create_data_model():
      """Stores the data for the problem."""
    
      data1 = {}
      data1['time_windows'] =time_windows_new
      data1['time_matrix'] = time_matrix2
      # [START starts_ends]
      data1['starts'] =multi_depot
      data1['ends'] =multi_endhub
      data1['num_vehicles']=num_vehiclemax;
      data1['demands']=demands_multidepot
      data1['vehicle_capacities'] =vehicle_capacitys
      # [END starts_ends]
      return data1
      # [END data_model]
      
    # [START solution_printer]
    def print_solution(data1, manager, routing, solution):
      total_distance = 0
      total_load = 0
      time_dimension = routing.GetDimensionOrDie('Time')
      total_time = 0
      time_ss=[]
      for vehicle_id in range(data1['num_vehicles']):
        index = routing.Start(vehicle_id)
        plan_output = 'Route for vehicle {}:\n'.format(vehicle_id)
        route_load = 0      
        while not routing.IsEnd(index):
          node_index = manager.IndexToNode(index)
          time_var = (time_dimension.CumulVar(index))
          route_load += data1['demands'][node_index]
          plan_output += 'Place {0:>2} Arrive at {2:>2}sec Depart at {3:>2}sec (Load {1:>2})\n'.format(manager.IndexToNode(index),  route_load,solution.Min(time_var),solution.Max(time_var))
          # output_list1.append('{0}'.format(manager.IndexToNode(index)))
          time_ss.append([manager.IndexToNode(index),solution.Max(time_var),route_load])
          previous_index = index
          index = solution.Value(routing.NextVar(index))
        
        time_var = time_dimension.CumulVar(index)
        total_time += solution.Min(time_var)
        plan_output +="Place {0:>2} Arrive at {2:>2}sec \n\n".format(manager.IndexToNode(index), route_load,solution.Min(time_var),solution.Max(time_var))
        plan_output += 'Load of the route: {}\n'.format(route_load)
        plan_output += 'Time of the route: {}sec\n'.format(solution.Min(time_var))
        plan_output += "--------------------"
        time_ss.append([manager.IndexToNode(index),solution.Min(time_var),route_load])
        time_list4[vehicle_id]=time_ss
        time_ss=[]
        
        
        
        # output_list1.append(-1)
        print(plan_output)
        total_load += route_load


      print('Total load of all routes: {}'.format(total_load))
      print('Total time of all routes: {}sec'.format(total_time))
      # [END solution_printer]
    def main4():
      """Entry point of the program."""
      # Instantiate the data problem.
      # [START data]
      data1 = create_data_model()
      # [END data]
      # Create the routing index manager.
      # [START index_manager]
      manager = pywrapcp.RoutingIndexManager(len(data1['time_matrix']),
                                           data1['num_vehicles'], data1['starts'],
                                           data1['ends'])
      # [END index_manager]

      # Create Routing Model.
      # [START routing_model]
      routing = pywrapcp.RoutingModel(manager)

      # [END routing_model]

      # Create and register a transit callback.
      # [START transit_callback]
      def time_callback(from_index, to_index):
        """Returns the travel time between the two nodes."""
        # Convert from routing variable Index to time matrix NodeIndex.
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return data1['time_matrix'][from_node][to_node]

      transit_callback_index = routing.RegisterTransitCallback(time_callback)
      routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)#
      
      
      # [END transit_callback]
      # Add Capacity constraint.
      def demand_callback(from_index):
        """Returns the demand of the node."""
        # Convert from routing variable Index to demands NodeIndex.
        from_node = manager.IndexToNode(from_index)
        return data1['demands'][from_node]

      demand_callback_index = routing.RegisterUnaryTransitCallback(
        demand_callback)
      routing.AddDimensionWithVehicleCapacity(
        demand_callback_index,
        0,  # null capacity slack
        data1['vehicle_capacities'],  # vehicle maximum capacities
        True,  # start cumul to zero
        'Capacity')
      
      # Define cost of each arc.
      # [START arc_cost]
      routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)
      # [END arc_cost]

      # Add Distance constraint.
      # [START distance_constraint]
      time = 'Time'
      routing.AddDimension(
        transit_callback_index,
        0,  # allow waiting time
        300*60,  # maximum time per vehicle
        False,  # Don't force start cumul to zero.
        time)
      time_dimension = routing.GetDimensionOrDie(time)

      for location_idx, time_window in enumerate(data1['time_windows']):
        if location_idx == 0:
          continue
        index = manager.NodeToIndex(location_idx)
        time_dimension.CumulVar(index).SetRange(time_window[0], time_window[1])
        
      # Add time window constraints for each vehicle start node.
      for vehicle_id in range(data1['num_vehicles']):
        index = routing.Start(vehicle_id)
        time_dimension.CumulVar(index).SetRange(data1['time_windows'][0][0],
                                                data1['time_windows'][0][1])

      # Instantiate route start and end times to produce feasible times.
      for i in range(data1['num_vehicles']):
        routing.AddVariableMinimizedByFinalizer(
            time_dimension.CumulVar(routing.Start(i)))
        routing.AddVariableMinimizedByFinalizer(
            time_dimension.CumulVar(routing.End(i)))
  
      # Setting first solution heuristic.
      # [START parameters]
      search_parameters = pywrapcp.DefaultRoutingSearchParameters()
      search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.AUTOMATIC)
      search_parameters.time_limit.seconds = time_limit_seconds
      search_parameters.local_search_metaheuristic =(
      routing_enums_pb2.LocalSearchMetaheuristic.AUTOMATIC)
      search_parameters.time_limit.seconds = time_limit_seconds
    
      # [END parameters]

      # Solve the problem.
      # [START solve]
      solution = routing.SolveWithParameters(search_parameters)
      # [END solve]

      # Print solution on console.
      # [START print_solution]
      if solution:
        print_solution(data1, manager, routing, solution)
      return solution
    # [END print_solution]
    solution = main4()
    
  # def assigning_value_to_time_list4(pickup_add_link,add,pickup_demand_link,pickup_add):
  #   global time_list4
  #   pickup_vrp(pickup_add_link,add,pickup_demand_link)

  def update_time_list(time_list4,list1):
    
    for key,value in dict(time_list4).items():
      for j in value:
        j[0]=list1[int(j[0])]
    return time_list4


  def update_updated_initial_route_of_delivery(time_list4,updated_initial_route_of_delivery,add,awb,latitude_total,longitude_total):
    # add,awb=merge(pickup_add_link,add,awb)
    # latitude_total,longitude_total=lat_long_pickup(add)
    for key,value in dict(updated_initial_route_of_delivery).items():
      del value[len(value)-1]
    for key,value in dict(time_list4).items():
      del value[0]
      for j in value:
        updated_initial_route_of_delivery[key].append(j)
    for key,value in dict(updated_initial_route_of_delivery).items():
      for j in value:
        j.append(awb[j[0]])
        j.append(add[j[0]])
        j.append(latitude_total[j[0]])
        j.append(longitude_total[j[0]])
    return updated_initial_route_of_delivery
  def create_final_csv(updated_initial_route_of_delivery):
    for key,value in dict(updated_initial_route_of_delivery).items():
      Nodes=[]
      Time=[]
      Load=[]
      Address=[]
      AWB_NO=[]
      latitude=[]
      longitude=[]
      for j in value:
        Nodes.append(j[0])
        Time.append(j[1])
        Load.append(j[2])
        Address.append(j[4])
        AWB_NO.append(j[3])
        latitude.append(j[5])
        longitude.append(j[6])
      final_dict = {'Nodes': Nodes, 'Time': Time, 'Load': Load,'AWB_NO':AWB_NO,'Address':Address,'latitude':latitude,'longitude':longitude}  
      df = pd.DataFrame(final_dict)
      df.to_csv(f'Final_Driver{key}.csv')


  delivery_add=create_delivery_add(add)
  print(delivery_add)
  add,awb=merge(pickup_add_link,add,awb)
  print(add,awb)
  print(len(add))
  
  pickup_add=add_pickup(pickup_add_link)
  print(pickup_add)
  list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
  print(list1)
  print(list2)
  print(time_listupdate)
  address=address(delivery_add,list1)
  print(address)
  latitude_total,longitude_total=lat_long_pickup(add)
  print(latitude_total)
  print(longitude_total)
  list1=appending_list1_forpickup(pickup_add,list1,delivery_add)
  print(list1)
  address=update_address(address,pickup_add)
  print(address)
  latitude_partial,longitude_partial=lat_long_pickup1(address)
  time_matrix2=time_matrix(latitude_partial,longitude_partial)
  print(time_matrix2)
  multi_depot,multi_endhub=multi_end_and_depot(list2)
  print(multi_depot,multi_endhub)
  demands_multidepot=pickup_demands(pickup_demand_link,multi_depot)
  print(demands_multidepot)
  num_vehiclemax,vehicle_capacitys=numvech_max_and_vehiclecap(list2)
  print(num_vehiclemax,vehicle_capacitys)
  time_windows_new=creating_timewindow_new(pickup_add_link,time_listupdate)
  print(time_windows_new)
  time_list4={} 
  pickup_vrp(time_windows_new,time_matrix2,multi_depot,multi_endhub,demands_multidepot,num_vehiclemax,vehicle_capacitys,time_list4)
  print(time_list4)
  time_list4=update_time_list(time_list4,list1)
  print(time_list4)
  updated_initial_route_of_delivery=update_updated_initial_route_of_delivery(time_list4,updated_initial_route_of_delivery,add,awb,latitude_total,longitude_total)
  print(updated_initial_route_of_delivery)
  create_final_csv(updated_initial_route_of_delivery)
  print(updated_initial_route_of_delivery)
  return updated_initial_route_of_delivery,add,awb

updated_initial_route_of_delivery,add,awb=pickup(updated_initial_route_of_delivery,add,awb,pickup_add_link,pickup_demand_link,API_KEY)

pickup_add_link="/content/pickup2_delivery.csv"
pickup_demand_link="/content/pickup2_demands.csv"

def second_pickup(updated_initial_route_of_delivery,add,awb,pickup_add_link,pickup_demand_link,API_KEY):
  # time_list4={}
  

  def create_delivery_add(add):
    delivery_add=[]
    for i in add:
      i=i.replace(" ","+")
      delivery_add.append(i)
    return delivery_add
  # the previous data used 1st pickup (using few functions for 1st pickup)
  # not general
  def merge(pickup_add_link,add,awb):
    merge2add=[]
    merge2awb=[]
    dfp = pd.read_csv(pickup_add_link)
    merge2add= dfp['address'].to_list()
    merge2awb=dfp['AWB'].to_list()
    add=add+merge2add
    awb=awb+merge2awb
    # print(add,awb)
    return add,awb


  


  # general pickup
  def add_pickup(pickup_add_link):
    dfp = pd.read_csv(pickup_add_link)
    pickupadd_list= dfp['address'].to_list()
    for i in range(len(pickupadd_list)):
      pickupadd_list[i]=pickupadd_list[i].replace(" ","+")
    pickup_add=pickupadd_list
    # print(pickup_add)
    return pickup_add 

  #general pickup
  def pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery):
    list1=[]
    list2=[]
    time_listupdate=[]
    load_listupdate=[]
    time_listupdate.append(0)
    load_listupdate.append(0)
    list1.append(0)
    list2.append(0)
    for key,value in dict(updated_initial_route_of_delivery).items():
      for i in range (len(value)):
        if(i==len(value)-2):
          list1.append(value[i][0])
          list2.append(value[i][0])
          time_listupdate.append(value[i][1])
          load_listupdate.append(value[i][2])
    # print(list1,list2,time_listupdate)
    return list1,list2,time_listupdate,load_listupdate


    #general pickup
  def address(delivery_add,list1):
    # list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
    adresses=[]
    for i in list1:
      adresses.append(delivery_add[int(i)])
    # print(adresses)
    return adresses


  

  #general pickup
  def lat_long_pickup(add):
    latitude_total=[]
    longitude_total=[]
    for i in range(len(add)):
      r = requests.get('https://maps.googleapis.com/maps/api/geocode/json?address=' + add[i] +'&key=' + API_KEY)
      resp = json.loads(r.text)
      print(resp)
      lat = resp['results'][0]['geometry']['location']['lat']
      lon = resp['results'][0]['geometry']['location']['lng']
      latitude_total.append(lat)
      longitude_total.append(lon)
      # print(latitude_total,longitude_total)
    return latitude_total,longitude_total

  # #not general pickup
  def appending_list1_forpickup(pickup_add,list1,delivery_add):
    # list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
    size= len(delivery_add)
    for i in range(len(pickup_add)):
      list1.append(size+i)
    # print(list1)
    return list1
  def update_address(adresses,pickup_add):
    for i in pickup_add:
      adresses.append(i)
    return adresses

  def lat_long_pickup1(adresses):
    latitude_partial=[]
    longitude_partial=[]
    for i in range(len(adresses)):
      r = requests.get('https://maps.googleapis.com/maps/api/geocode/json?address=' + add[i] +'&key=' + API_KEY)
      resp = json.loads(r.text)
      lat = resp['results'][0]['geometry']['location']['lat']
      lon = resp['results'][0]['geometry']['location']['lng']
      latitude_partial.append(lat)
      longitude_partial.append(lon)
      # print(latitude_total,longitude_total)
    return latitude_partial,longitude_partial

  def time_calculator(lon1, lat1, lon2, lat2):
    lon1, lat1, lon2, lat2 = map(np.radians, [lon1, lat1, lon2, lat2])
    newlon = lon2 - lon1
    newlat = lat2 - lat1
    haver_formula = np.sin(newlat/2.0)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(newlon/2.0)**2
    dist = 2 * np.arcsin(np.sqrt(haver_formula ))
    m = 6367 * dist *1000
    time=m/6.11
    return int(math.floor(time))

  #general pickup
  def time_matrix(latitude_partial,longitude_partial):
    # def create_time_matrix(latitude_delivery,longitude_delivery):
    time_matrix = np.zeros((len(latitude_partial),len(longitude_partial)))
    for i in range(len(latitude_partial)):
      for j in range(len(longitude_partial)):
        # calculate the distance using the distance matrix function
        time_matrix[i, j] = time_calculator(longitude_partial[i], latitude_partial[i],longitude_partial[j],latitude_partial[j])
    return time_matrix
    
 #general pickup
  def multi_end_and_depot(list2):
  #  list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
   multi_depot=[]
   multi_endhub=[]
   for i in range(1,len(list2)):
     multi_depot.append(i)
   for i in range(len(multi_depot)):
     multi_endhub.append(0)   
  #  print(multi_depot,multi_endhub)
   return multi_depot,multi_endhub


  def pickup_demands(pickup_demand_link,multi_depot,load_listupdate):
    # multi_depot,multi_endhub=multi_end_and_depot(updated_initial_route_of_delivery)
    demands_multidepot=[]
    # demands_multidepot.append(0)
    for i in range(len(multi_depot)+1):
      demands_multidepot.append(load_listupdate[i])
    pickupdemands_list=[]
    dfpd = pd.read_csv(pickup_demand_link)
    pickupdemands_list= dfpd['demand'].to_list()
    for i in pickupdemands_list:
      demands_multidepot.append(i)
    # print(demands_multidepot)
    return demands_multidepot

  def numvech_max_and_vehiclecap(list2):
    # list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
    num_vehiclemax=len(list2)-1
    vehicle_capacitys=[]
    for i in range(num_vehiclemax):
      vehicle_capacitys.append(640000)
    print(num_vehiclemax,vehicle_capacitys)
    return num_vehiclemax,vehicle_capacitys


  def creating_timewindow_new(pickup_add_link,time_listupdate):
    # list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
    time_windows_new=[]
    pickup_add=add_pickup(pickup_add_link)
    for i in range(len(time_listupdate)):
      time_windows_new.append((time_listupdate[i],300*60))
    for i in range(len(pickup_add)):
      time_windows_new.append((0,300*60))
    print(time_windows_new)
    return time_windows_new


  def pickup_vrp(time_windows_new,time_matrix2,multi_depot,multi_endhub,demands_multidepot,num_vehiclemax,vehicle_capacitys,time_list4):
    time_limit_seconds = 60 # time limit for calculation
    # time_windows_new=creating_timewindow_new(pickup_add_link,updated_initial_route_of_delivery)
    # time_matrix2=time_matrix(address)
    # multi_depot,multi_endhub=multi_end_and_depot(updated_initial_route_of_delivery)
    # demands_multidepot=pickup_demands(pickup_demand_link,updated_initial_route_of_delivery)
    # num_vehiclemax,vehicle_capacitys=numvech_max_and_vehiclecap(updated_initial_route_of_delivery)
    # time_list4={}
    # [START data_model]
    def create_data_model():
      """Stores the data for the problem."""
    
      data1 = {}
      data1['time_windows'] =time_windows_new
      data1['time_matrix'] = time_matrix2
      # [START starts_ends]
      data1['starts'] =multi_depot
      data1['ends'] =multi_endhub
      data1['num_vehicles']=num_vehiclemax;
      data1['demands']=demands_multidepot
      data1['vehicle_capacities'] =vehicle_capacitys
      # [END starts_ends]
      return data1
      # [END data_model]
      
    # [START solution_printer]
    def print_solution(data1, manager, routing, solution):
      total_distance = 0
      total_load = 0
      time_dimension = routing.GetDimensionOrDie('Time')
      total_time = 0
      time_ss=[]
      for vehicle_id in range(data1['num_vehicles']):
        index = routing.Start(vehicle_id)
        plan_output = 'Route for vehicle {}:\n'.format(vehicle_id)
        route_load = 0      
        while not routing.IsEnd(index):
          node_index = manager.IndexToNode(index)
          time_var = (time_dimension.CumulVar(index))
          route_load += data1['demands'][node_index]
          plan_output += 'Place {0:>2} Arrive at {2:>2}sec Depart at {3:>2}sec (Load {1:>2})\n'.format(manager.IndexToNode(index),  route_load,solution.Min(time_var),solution.Max(time_var))
          # output_list1.append('{0}'.format(manager.IndexToNode(index)))
          time_ss.append([manager.IndexToNode(index),solution.Max(time_var),route_load])
          previous_index = index
          index = solution.Value(routing.NextVar(index))
        
        time_var = time_dimension.CumulVar(index)
        total_time += solution.Min(time_var)
        plan_output +="Place {0:>2} Arrive at {2:>2}sec \n\n".format(manager.IndexToNode(index), route_load,solution.Min(time_var),solution.Max(time_var))
        plan_output += 'Load of the route: {}\n'.format(route_load)
        plan_output += 'Time of the route: {}sec\n'.format(solution.Min(time_var))
        plan_output += "--------------------"
        time_ss.append([manager.IndexToNode(index),solution.Min(time_var),route_load])
        time_list4[vehicle_id]=time_ss
        time_ss=[]
        
        
        
        # output_list1.append(-1)
        print(plan_output)
        total_load += route_load


      print('Total load of all routes: {}'.format(total_load))
      print('Total time of all routes: {}sec'.format(total_time))
      # [END solution_printer]
    def main4():
      """Entry point of the program."""
      # Instantiate the data problem.
      # [START data]
      data1 = create_data_model()
      # [END data]
      # Create the routing index manager.
      # [START index_manager]
      manager = pywrapcp.RoutingIndexManager(len(data1['time_matrix']),
                                           data1['num_vehicles'], data1['starts'],
                                           data1['ends'])
      # [END index_manager]

      # Create Routing Model.
      # [START routing_model]
      routing = pywrapcp.RoutingModel(manager)

      # [END routing_model]

      # Create and register a transit callback.
      # [START transit_callback]
      def time_callback(from_index, to_index):
        """Returns the travel time between the two nodes."""
        # Convert from routing variable Index to time matrix NodeIndex.
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return data1['time_matrix'][from_node][to_node]

      transit_callback_index = routing.RegisterTransitCallback(time_callback)
      routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)#
      
      
      # [END transit_callback]
      # Add Capacity constraint.
      def demand_callback(from_index):
        """Returns the demand of the node."""
        # Convert from routing variable Index to demands NodeIndex.
        from_node = manager.IndexToNode(from_index)
        return data1['demands'][from_node]

      demand_callback_index = routing.RegisterUnaryTransitCallback(
        demand_callback)
      routing.AddDimensionWithVehicleCapacity(
        demand_callback_index,
        0,  # null capacity slack
        data1['vehicle_capacities'],  # vehicle maximum capacities
        True,  # start cumul to zero
        'Capacity')
      
      # Define cost of each arc.
      # [START arc_cost]
      routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)
      # [END arc_cost]

      # Add Distance constraint.
      # [START distance_constraint]
      time = 'Time'
      routing.AddDimension(
        transit_callback_index,
        0,  # allow waiting time
        300*60,  # maximum time per vehicle
        False,  # Don't force start cumul to zero.
        time)
      time_dimension = routing.GetDimensionOrDie(time)

      for location_idx, time_window in enumerate(data1['time_windows']):
        if location_idx == 0:
          continue
        index = manager.NodeToIndex(location_idx)
        time_dimension.CumulVar(index).SetRange(time_window[0], time_window[1])
        
      # Add time window constraints for each vehicle start node.
      for vehicle_id in range(data1['num_vehicles']):
        index = routing.Start(vehicle_id)
        time_dimension.CumulVar(index).SetRange(data1['time_windows'][0][0],
                                                data1['time_windows'][0][1])

      # Instantiate route start and end times to produce feasible times.
      for i in range(data1['num_vehicles']):
        routing.AddVariableMinimizedByFinalizer(
            time_dimension.CumulVar(routing.Start(i)))
        routing.AddVariableMinimizedByFinalizer(
            time_dimension.CumulVar(routing.End(i)))
  
      # Setting first solution heuristic.
      # [START parameters]
      search_parameters = pywrapcp.DefaultRoutingSearchParameters()
      search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.AUTOMATIC)
      search_parameters.time_limit.seconds = time_limit_seconds
      search_parameters.local_search_metaheuristic =(
      routing_enums_pb2.LocalSearchMetaheuristic.AUTOMATIC)
      search_parameters.time_limit.seconds = time_limit_seconds
    
      # [END parameters]

      # Solve the problem.
      # [START solve]
      solution = routing.SolveWithParameters(search_parameters)
      # [END solve]

      # Print solution on console.
      # [START print_solution]
      if solution:
        print_solution(data1, manager, routing, solution)
      return solution
    # [END print_solution]
    solution = main4()
    
  # def assigning_value_to_time_list4(pickup_add_link,add,pickup_demand_link,pickup_add):
  #   global time_list4
  #   pickup_vrp(pickup_add_link,add,pickup_demand_link)

  def update_time_list(time_list4,list1):
    
    for key,value in dict(time_list4).items():
      for j in value:
        j[0]=list1[int(j[0])]
    return time_list4


  def update_updated_initial_route_of_delivery(time_list4,updated_initial_route_of_delivery,add,awb,latitude_total,longitude_total):
    # add,awb=merge(pickup_add_link,add,awb)
    # latitude_total,longitude_total=lat_long_pickup(add)
    for key,value in dict(updated_initial_route_of_delivery).items():
      del value[len(value)-1]
    for key,value in dict(time_list4).items():
      del value[0]
      for j in value:
        updated_initial_route_of_delivery[key].append(j)
    for key,value in dict(updated_initial_route_of_delivery).items():
      for j in value:
        j.append(awb[j[0]])
        j.append(add[j[0]])
        j.append(latitude_total[j[0]])
        j.append(longitude_total[j[0]])
    return updated_initial_route_of_delivery
  def create_final_csv(updated_initial_route_of_delivery):
    for key,value in dict(updated_initial_route_of_delivery).items():
      Nodes=[]
      Time=[]
      Load=[]
      Address=[]
      AWB_NO=[]
      latitude=[]
      longitude=[]
      for j in value:
        Nodes.append(j[0])
        Time.append(j[1])
        Load.append(j[2])
        Address.append(j[4])
        AWB_NO.append(j[3])
        latitude.append(j[5])
        longitude.append(j[6])
      final_dict = {'Nodes': Nodes, 'Time': Time, 'Load': Load,'AWB_NO':AWB_NO,'Address':Address,'latitude':latitude,'longitude':longitude}  
      df = pd.DataFrame(final_dict)
      df.to_csv(f'Final_Driver1{key}.csv')


  delivery_add=create_delivery_add(add)
  print(delivery_add)
  add,awb=merge(pickup_add_link,add,awb)
  print(add,awb)
  print(len(add))
  
  pickup_add=add_pickup(pickup_add_link)
  print(pickup_add)
  list1,list2,time_listupdate,load_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
  print(list1)
  print(list2)
  print(time_listupdate)
  print(load_listupdate)
  address=address(delivery_add,list1)
  print(address)
  latitude_total,longitude_total=lat_long_pickup(add)
  print(latitude_total)
  print(longitude_total)
  list1=appending_list1_forpickup(pickup_add,list1,delivery_add)
  print(list1)
  address=update_address(address,pickup_add)
  print(address)
  latitude_partial,longitude_partial=lat_long_pickup1(address)
  time_matrix2=time_matrix(latitude_partial,longitude_partial)
  print(time_matrix2)
  multi_depot,multi_endhub=multi_end_and_depot(list2)
  print(multi_depot,multi_endhub)
  demands_multidepot=pickup_demands(pickup_demand_link,multi_depot,load_listupdate)
  print(demands_multidepot)
  num_vehiclemax,vehicle_capacitys=numvech_max_and_vehiclecap(list2)
  print(num_vehiclemax,vehicle_capacitys)
  time_windows_new=creating_timewindow_new(pickup_add_link,time_listupdate)
  print(time_windows_new)
  time_list4={} 
  pickup_vrp(time_windows_new,time_matrix2,multi_depot,multi_endhub,demands_multidepot,num_vehiclemax,vehicle_capacitys,time_list4)
  print(time_list4)
  time_list4=update_time_list(time_list4,list1)
  print(time_list4)
  updated_initial_route_of_delivery=update_updated_initial_route_of_delivery(time_list4,updated_initial_route_of_delivery,add,awb,latitude_total,longitude_total)
  print(updated_initial_route_of_delivery)
  create_final_csv(updated_initial_route_of_delivery)
  print(updated_initial_route_of_delivery)
  return updated_initial_route_of_delivery,add,awb



updated_initial_route_of_delivery,add,awb=second_pickup(updated_initial_route_of_delivery,add,awb,pickup_add_link,pickup_demand_link,API_KEY)

print(updated_initial_route_of_delivery)
print(updated_initial_route_of_delivery[1])
print(add)
print(len(add))
print(awb)
print(len(awb))

# API_KEY = 'AIzaSyCtfZjJ6cJO1EkdIpDSX_o1CPELWV456Sc' 
# pickup_demand_link="/content/pickup2_demands.csv"
# pickup_add_link="/content/pickup2_delivery.csv"

# updated_initial_route_of_delivery,add,awb=second_pickup(updated_initial_route_of_delivery,add,awb,pickup_add_link,pickup_demand_link,API_KEY)



# def pickup(updated_initial_route_of_delivery,add,awb,pickup_add_link,pickup_demand_link):
#   # time_list4={}
#   size= len(delivery_add)
#   # the previous data used 1st pickup (using few functions for 1st pickup)
#   # not general
#   def merge(pickup_add_link):
#     merge2add=[]
#     merge2awb=[]
#     dfp = pd.read_csv(pickup_add_link)
#     merge2add= dfp['address'].to_list()
#     merge2awb=dfp['AWB'].to_list()
#     add=add+merge2add
#     awb=awb+merge2awb
#     return add,awb
#   # general pickup
#   def add_pickup(pickup_add_link):
#     dfp = pd.read_csv(pickup_add_link)
#     pickupadd_list= dfp['address'].to_list()
#     for i in range(len(pickupadd_list)):
#       pickupadd_list[i]=pickupadd_list[i].replace(" ","+")
#     pickup_add=pickupadd_list
#     return pickup_add 

#   #general pickup
#   def pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery):
#     list1=[]
#     list2=[]
#     time_listupdate=[]
#     time_listupdate.append(0)
#     list1.append(0)
#     list2.append(0)
#     for key,value in dict(updated_initial_route_of_delivery).items():
#       for i in range (len(value)):
#         if(i==len(value)-2):
#           list1.append(value[i][0])
#           list2.append(value[i][0])
#           time_listupdate.append(value[i][1])
#     return list1,list2,time_listupdate


#     #general pickup
#   def address(add):
#     list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
#     adresses=[]
#     for i in list1:
#       adresses.append(add[int(i)])
#     return adresses

#   #general pickup
#   def lat_long_pickup(add):
#     latitude_total=[]
#     longitude_total=[]
#     for i in range(len(add)):
#       r = requests.get('https://maps.googleapis.com/maps/api/geocode/json?address=' + add[i] +'&key=' + API_KEY)
#       resp = json.loads(r.text)
#       lat = resp['results'][0]['geometry']['location']['lat']
#       lon = resp['results'][0]['geometry']['location']['lng']
#       latitude_total.append(lat)
#       longitude_total.append(lon)
#       return latitude_total,longitude_total

#   # #not general pickup
#   def appending_list1_forpickup(pickup_add,updated_initial_route_of_delivery):
#     list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
#     for i in range(len(pickup_add)):
#       list1.append(size+i)
#     return list1


#   #general pickup
#   def time_matrix(add):
#     def create_data():
#       """Creates the data."""
#       adresses=address(add)
#       data = {}
#       data['addresses']=adresses
#       data['API_key'] = API_KEY  
#       return data
    
#     def send_request(origin_addresses, dest_addresses, API_key):
#        """ Build and send request for the given origin and destination addresses."""
#        def build_address_str(addresses):
#          # Build a pipe-separated string of addresses
#          address_str = ''
#          for i in range(len(addresses) - 1):
#            address_str += addresses[i] + '|'
#            address_str += addresses[-1]
#          return address_str
         
#        request = 'https://maps.googleapis.com/maps/api/distancematrix/json?units=imperial'
#        origin_address_str = build_address_str(origin_addresses)
#        dest_address_str = build_address_str(dest_addresses)
#        request = request + '&origins=' + origin_address_str + '&destinations=' + \
#                        dest_address_str + '&key=' + API_key
#        jsonResult = urllib.request.urlopen(request).read()
#        response = json.loads(jsonResult)
#        return response
       
#     def build_duration_matrix(response):
#       time_matrix = []
#       for row in response['rows']:
#         row_list = [row['elements'][j]['duration']['value'] for j in range(len(row['elements']))]
#         time_matrix.append(row_list)
#         # time_matrix1=time_matrix
#         return time_matrix
#     def create_time_matrix(data):
#       addresses = data["addresses"]
#       API_key = data["API_key"]
#       # Distance Matrix API only accepts 100 elements per request, so get rows in multiple requests.
#       max_elements = 100
#       num_addresses = len(addresses) # 16 in this example.
#       # Maximum number of rows that can be computed per request (6 in this example).
#       max_rows = max_elements // num_addresses
#       # num_addresses = q * max_rows + r (q = 2 and r = 4 in this example).
#       q, r = divmod(num_addresses, max_rows)
#       dest_addresses = addresses
#       time_matrix = []
#       # Send q requests, returning max_rows rows per request.
#       for i in range(q):
#         origin_addresses = addresses[i * max_rows: (i + 1) * max_rows]
#         response = send_request(origin_addresses, dest_addresses, API_key)
#         time_matrix += build_duration_matrix(response)
#         # Get the remaining remaining r rows, if necessary.
#       if r > 0:
#         origin_addresses = addresses[q * max_rows: q * max_rows + r]
#         response = send_request(origin_addresses, dest_addresses, API_key)
#         time_matrix += build_duration_matrix(response)
#       return time_matrix
#     data=create_data()
#     time_matrix2=create_time_matrix(data)
#     return time_matrix2
    
#  #general pickup
#   def multi_end_and_depot(updated_initial_route_of_delivery):
#    list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
#    multi_depot=[]
#    multi_endhub=[]
#    for i in range(1,len(list2)):
#      multi_depot.append(i)
#    for i in range(len(multi_depot)):
#      multi_endhub.append(0)   
#    return multi_depot,multi_endhub


#   def pickup_demands(pickup_demand_link):
#     multi_depot,multi_endhub=multi_end_and_depot()
#     demands_multidepot=[]
#     for i in range(len(multi_depot)+1):
#       demands_multidepot.append(0)
#     pickupdemands_list=[]
#     dfpd = pd.read_csv(pickup_demand_link)
#     pickupdemands_list= dfpd['demands'].to_list()
#     for i in pickupdemands_list:
#       demands_multidepot.append(i)
#     return demands_multidepot

#   def numvech_max_and_vehiclecap(updated_initial_route_of_delivery):
#     list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
#     num_vehiclemax=len(list2)-1
#     vehicle_capacitys=[]
#     for i in range(num_vehiclemax):
#       vehicle_capacitys.append(640000)
#     return num_vehiclemax,vehicle_capacitys


#   def creating_timewindow_new(pickup_add_link,updated_initial_route_of_delivery):
#     list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
#     time_windows_new=[]
#     pickup_add=add_pickup(pickup_add_link)
#     for i in range(len(time_listupdate)):
#       time_windows_new.append((time_listupdate[i],300*60))
#     for i in range(len(pickup_add)):
#       time_windows_new.append((0,300*60))
#     return time_windows_new


#   def pickup_vrp(pickup_add_link,add,pickup_demand_link,time_list4):
#     time_limit_seconds = 60 # time limit for calculation
#     time_windows_new=creating_timewindow_new(pickup_add_link)
#     time_matrix2=time_matrix(add)
#     multi_depot,multi_endhub=multi_end_and_depot()
#     demands_multidepot=pickup_demands(pickup_demand_link)
#     num_vehiclemax,vehicle_capacitys=numvech_max_and_vehiclecap()
#     # time_list4={}
#     # [START data_model]
#     def create_data_model():
#       """Stores the data for the problem."""
    
#       data1 = {}
#       data1['time_windows'] =time_windows_new
#       data1['time_matrix'] = time_matrix2
#       # [START starts_ends]
#       data1['starts'] =multi_depot
#       data1['ends'] =multi_endhub
#       data1['num_vehicles']=num_vehiclemax;
#       data1['demands']=demands_multidepot
#       data1['vehicle_capacities'] =vehicle_capacitys
#       # [END starts_ends]
#       return data1
#       # [END data_model]
      
#     # [START solution_printer]
#     def print_solution(data1, manager, routing, solution,output_list1):
#       total_distance = 0
#       total_load = 0
#       time_dimension = routing.GetDimensionOrDie('Time')
#       total_time = 0
#       time_ss=[]
#       for vehicle_id in range(data1['num_vehicles']):
#         index = routing.Start(vehicle_id)
#         plan_output = 'Route for vehicle {}:\n'.format(vehicle_id)
#         route_load = 0      
#         while not routing.IsEnd(index):
#           node_index = manager.IndexToNode(index)
#           time_var = (time_dimension.CumulVar(index))
#           route_load += data1['demands'][node_index]
#           plan_output += 'Place {0:>2} Arrive at {2:>2}sec Depart at {3:>2}sec (Load {1:>2})\n'.format(manager.IndexToNode(index),  route_load,solution.Min(time_var),solution.Max(time_var))
#           output_list1.append('{0}'.format(manager.IndexToNode(index)))
#           time_ss.append([manager.IndexToNode(index),solution.Max(time_var),route_load])
#           previous_index = index
#           index = solution.Value(routing.NextVar(index))
        
#         time_var = time_dimension.CumulVar(index)
#         total_time += solution.Min(time_var)
#         plan_output +="Place {0:>2} Arrive at {2:>2}sec \n\n".format(manager.IndexToNode(index), route_load,solution.Min(time_var),solution.Max(time_var))
#         plan_output += 'Load of the route: {}\n'.format(route_load)
#         plan_output += 'Time of the route: {}sec\n'.format(solution.Min(time_var))
#         plan_output += "--------------------"
#         time_ss.append([manager.IndexToNode(index),solution.Min(time_var),route_load])
#         time_list4[vehicle_id]=time_ss
#         time_ss=[]
        
        
        
#         # output_list1.append(-1)
#         print(plan_output)
#         total_load += route_load


#       print('Total load of all routes: {}'.format(total_load))
#       print('Total time of all routes: {}sec'.format(total_time))
#       # [END solution_printer]
#     def main4():
#       """Entry point of the program."""
#       # Instantiate the data problem.
#       # [START data]
#       data1 = create_data_model()
#       # [END data]
#       # Create the routing index manager.
#       # [START index_manager]
#       manager = pywrapcp.RoutingIndexManager(len(data1['time_matrix']),
#                                            data1['num_vehicles'], data1['starts'],
#                                            data1['ends'])
#       # [END index_manager]

#       # Create Routing Model.
#       # [START routing_model]
#       routing = pywrapcp.RoutingModel(manager)

#       # [END routing_model]

#       # Create and register a transit callback.
#       # [START transit_callback]
#       def time_callback(from_index, to_index):
#         """Returns the travel time between the two nodes."""
#         # Convert from routing variable Index to time matrix NodeIndex.
#         from_node = manager.IndexToNode(from_index)
#         to_node = manager.IndexToNode(to_index)
#         return data1['time_matrix'][from_node][to_node]

#       transit_callback_index = routing.RegisterTransitCallback(time_callback)
#       routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)#
      
      
#       # [END transit_callback]
#       # Add Capacity constraint.
#       def demand_callback(from_index):
#         """Returns the demand of the node."""
#         # Convert from routing variable Index to demands NodeIndex.
#         from_node = manager.IndexToNode(from_index)
#         return data1['demands'][from_node]

#       demand_callback_index = routing.RegisterUnaryTransitCallback(
#         demand_callback)
#       routing.AddDimensionWithVehicleCapacity(
#         demand_callback_index,
#         0,  # null capacity slack
#         data1['vehicle_capacities'],  # vehicle maximum capacities
#         True,  # start cumul to zero
#         'Capacity')
      
#       # Define cost of each arc.
#       # [START arc_cost]
#       routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)
#       # [END arc_cost]

#       # Add Distance constraint.
#       # [START distance_constraint]
#       time = 'Time'
#       routing.AddDimension(
#         transit_callback_index,
#         0,  # allow waiting time
#         300*60,  # maximum time per vehicle
#         False,  # Don't force start cumul to zero.
#         time)
#       time_dimension = routing.GetDimensionOrDie(time)

#       for location_idx, time_window in enumerate(data1['time_windows']):
#         if location_idx == 0:
#           continue
#         index = manager.NodeToIndex(location_idx)
#         time_dimension.CumulVar(index).SetRange(time_window[0], time_window[1])
        
#       # Add time window constraints for each vehicle start node.
#       for vehicle_id in range(data1['num_vehicles']):
#         index = routing.Start(vehicle_id)
#         time_dimension.CumulVar(index).SetRange(data1['time_windows'][0][0],
#                                                 data1['time_windows'][0][1])

#       # Instantiate route start and end times to produce feasible times.
#       for i in range(data1['num_vehicles']):
#         routing.AddVariableMinimizedByFinalizer(
#             time_dimension.CumulVar(routing.Start(i)))
#         routing.AddVariableMinimizedByFinalizer(
#             time_dimension.CumulVar(routing.End(i)))
  
#       # Setting first solution heuristic.
#       # [START parameters]
#       search_parameters = pywrapcp.DefaultRoutingSearchParameters()
#       search_parameters.first_solution_strategy = (
#         routing_enums_pb2.FirstSolutionStrategy.AUTOMATIC)
#       search_parameters.time_limit.seconds = time_limit_seconds
#       search_parameters.local_search_metaheuristic =(
#       routing_enums_pb2.LocalSearchMetaheuristic.AUTOMATIC)
#       search_parameters.time_limit.seconds = time_limit_seconds
    
#       # [END parameters]

#       # Solve the problem.
#       # [START solve]
#       solution = routing.SolveWithParameters(search_parameters)
#       # [END solve]

#       # Print solution on console.
#       # [START print_solution]
#       if solution:
#         print_solution(data1, manager, routing, solution)
#       return solution
#     # [END print_solution]
#     solution = main4()
    
#   # def assigning_value_to_time_list4(pickup_add_link,add,pickup_demand_link,pickup_add):
#   #   global time_list4
#   #   pickup_vrp(pickup_add_link,add,pickup_demand_link)

#   def update_time_list(pickup_add_link,time_list4):
#     pickup_add=add_pickup(pickup_add_link)
#     list1=appending_list1_forpickup(pickup_add)
#     for key,value in dict(time_list4).items():
#       for j in value:
#         j[0]=list1[int(j[0])]
#     return time_list4


#   def update_updated_initial_route_of_delivery(pickup_add_link,time_list4,updated_initial_route_of_delivery):
#     add,awb=merge(pickup_add_link)
#     latitude_total,longitude_total=lat_long_pickup(add)
#     for key,value in dict(updated_initial_route_of_delivery).items():
#       del value[len(value)-1]
#     for key,value in dict(time_list4).items():
#       del value[0]
#       for j in value:
#         updated_initial_route_of_delivery[key].append(j)
#     for key,value in dict(updated_initial_route_of_delivery).items():
#       for j in value:
#         j.append(awb[j[0]])
#         j.append(add[j[0]])
#         j.append(latitude_total[j[0]])
#         j.append(longitude_total[j[0]])
#     return updated_initial_route_of_delivery
#   def create_final_csv(updated_initial_route_of_delivery):
#     for key,value in dict(updated_initial_route_of_delivery).items():
#       Nodes=[]
#       Time=[]
#       Load=[]
#       Address=[]
#       AWB_NO=[]
#       latitude=[]
#       longitude=[]
#       for j in value:
#         Nodes.append(j[0])
#         Time.append(j[1])
#         Load.append(j[2])
#         Address.append(j[4])
#         AWB_NO.append(j[3])
#         latitude.append(j[5])
#         longitude.append(j[6])
#       final_dict = {'Nodes': Nodes, 'Time': Time, 'Load': Load,'AWB_NO':AWB_NO,'Address':Address,'latitude':latitude,'longitude':longitude}  
#       df = pd.DataFrame(final_dict)
#       df.to_csv(f'Final_Driver{key}.csv')


  
#   add,awb=merge(pickup_add_link)
#   pickup_add=add_pickup(pickup_add_link)
#   list1,list2,time_listupdate=pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
#   address=address(add)
#   latitude_total,longitude_total=lat_long_pickup()
#   list1=appending_list1_forpickup(pickup_add)
#   time_matrix2=time_matrix(add)
#   multi_depot,multi_endhub=multi_end_and_depot(updated_initial_route_of_delivery)
#   demands_multidepot=pickup_demands(pickup_demand_link)
#   num_vehiclemax,vehicle_capacitys=numvech_max_and_vehiclecap(updated_initial_route_of_delivery)
#   time_windows_new=creating_timewindow_new(pickup_add_link,updated_initial_route_of_delivery)
#   time_list4={}
#   pickup_vrp(pickup_add_link,add,pickup_demand_link,time_list4)
#   time_list4=update_time_list(pickup_add_link,time_list4)
#   updated_initial_route_of_delivery=update_updated_initial_route_of_delivery(pickup_add_link,time_list4,updated_initial_route_of_delivery)
#   create_final_csv(updated_initial_route_of_delivery)
#   print(updated_initial_route_of_delivery)

# # the previous data used 1st pickup (using few functions for 1st pickup)
# # not general
# def merge():
#   merge1add=[]
#   merge1awb=[]
#   df = pd.read_csv(delivery_addlink)
#   merge1add.append(df['address'].to_list())
#   merge1awb.append(df['AWB'].to_list())
#   merge2add=[]
#   merge2awb=[]
#   dfp = pd.read_csv(pickup_add_link)
#   merge2add= dfp['address'].to_list()
#   merge2awb=dfp['AWB'].to_list()
  
#   add=merge1add+merge2add
#   awb=merge1awb+merge2awb
#   return add,awb

# # general pickup
# def add_pickup():
#   dfp = pd.read_csv(pickup_add_link)
#   pickupadd_list= dfp['address'].to_list()
#   for i in range(len(pickupadd_list)):
#     pickupadd_list[i] = pickupadd_list[i].replace(" ","+")
#   pickup_add=pickupadd_list
#   return pickup_add

# #general pickup
# def pickup_start_takinglast_nodeandtime(updated_initial_route_of_delivery)
#  list1=[]
#  list2=[]
#  time_listupdate=[]
#  time_listupdate.append(0)
#  list1.append(0)
#  list2.append(0)
# for key,value in dict(updated_initial_route_of_delivery).items():
#   for i in range (len(value)):
#     if(i==len(value)-2):
#       list1.append(value[i][0])
#       list2.append(value[i][0])
#       time_listupdate.append(value[i][1])
#   return list1,list2,time_listupdate

# #general pickup
# def address():
#   for i in list1:
#     adresses.append(add[int(i)])
#   return adresses

# #general pickup
# def lat_long_pickup():
#   for i in range(len(add)):
#     r = requests.get('https://maps.googleapis.com/maps/api/geocode/json?address=' + add[i] +'&key=' + API_KEY)
#     resp = json.loads(r.text)
#     lat = resp['results'][0]['geometry']['location']['lat']
#     lon = resp['results'][0]['geometry']['location']['lng']
#     latitude_total.append(lat)
#     longitude_total.append(lon)
#   return latitude_total,longitude_total

# #not general pickup
# def appending_list1_forpickup():
  
#   for i in range(len(pickup_add)):
#     list1.append(size+i)
# return list1

#general pickup
# def appending_list1_forpickup():
#   size= len(add)
#   for i in range(len(pickup_add)):
#     list1.append(size+i)
# return list1

# #general pickup
# def time_matrix():
#  def create_data():
#   """Creates the data."""
#   data = {}
#   data['addresses']=adresses
#   data['API_key'] = API_KEY  
#   return data

#  def send_request(origin_addresses, dest_addresses, API_key):
#   """ Build and send request for the given origin and destination addresses."""
#   def build_address_str(addresses):
#     # Build a pipe-separated string of addresses
#     address_str = ''
#     for i in range(len(addresses) - 1):
#       address_str += addresses[i] + '|'
#     address_str += addresses[-1]
#     return address_str

#   request = 'https://maps.googleapis.com/maps/api/distancematrix/json?units=imperial'
#   origin_address_str = build_address_str(origin_addresses)
#   dest_address_str = build_address_str(dest_addresses)
#   request = request + '&origins=' + origin_address_str + '&destinations=' + \
#                        dest_address_str + '&key=' + API_key
#   jsonResult = urllib.request.urlopen(request).read()
#   response = json.loads(jsonResult)
#   return response


#  def build_duration_matrix(response):
#   time_matrix = []
#   for row in response['rows']:
#     row_list = [row['elements'][j]['duration']['value'] for j in range(len(row['elements']))]
#     time_matrix.append(row_list)
#   # time_matrix1=time_matrix
#   return time_matrix



#  def create_time_matrix(data):
#   addresses = data["addresses"]
#   API_key = data["API_key"]
#   # Distance Matrix API only accepts 100 elements per request, so get rows in multiple requests.
#   max_elements = 100
#   num_addresses = len(addresses) # 16 in this example.
#   # Maximum number of rows that can be computed per request (6 in this example).
#   max_rows = max_elements // num_addresses
#   # num_addresses = q * max_rows + r (q = 2 and r = 4 in this example).
#   q, r = divmod(num_addresses, max_rows)
#   dest_addresses = addresses
#   time_matrix = []
#   # Send q requests, returning max_rows rows per request.
#   for i in range(q):
#     origin_addresses = addresses[i * max_rows: (i + 1) * max_rows]
#     response = send_request(origin_addresses, dest_addresses, API_key)
#     time_matrix += build_duration_matrix(response)

#   # Get the remaining remaining r rows, if necessary.
#   if r > 0:
#     origin_addresses = addresses[q * max_rows: q * max_rows + r]
#     response = send_request(origin_addresses, dest_addresses, API_key)
#     time_matrix += build_duration_matrix(response)
#   return time_matrix
#  data=create_data()
#  time_matrix2=create_time_matrix(data)
#  return time_matrix2

# #general pickup

# def multi_end_and_depot():
#   for i in range(1,len(list2)):
#     multi_depot.append(i)
#   for i in range(len(multi_depot)):
#     multi_endhub.append(0)   
#   return multi_depot,multi_end

# def pickup_demands():
#   for i in range(len(multi_depot)+1):
#     demands_multidepot.append(0)
#   pickupdemands_list=[]
#   dfpd = pd.read_csv(pickup_demand_link)
#   pickupdemands_list= dfpd['demands'].to_list()
#   for i in pickupdemands_list:
#     demands_multidepot.append(i)
#   return demands_multidepot

# def numvech_max _and_vehiclecap():
#   num_vehiclemax=len(list2)-1
#   vehicle_capacitys=[]
#   for i in range(num_vehiclemax):
#     vehicle_capacitys.append(640000)
#   return num_vehiclemax,vehicle_capacitys

# def creating_timewindow_new():
#   for i in range(len(time_listupdate)):
#     time_windows_new.append((time_listupdate[i],300*60))
#   for i in range(len(pickup_add)):
#     time_windows_new.append((0,300*60))
#   return time_windows_new

# def pickup_vrp():
#   time_limit_seconds = 60 # time limit for calculation
#   time_windows_new=creating_timewindow_new()
#   time_matrix2=time_matrix()
#   multi_depot,multi_end=multi_end_and_depot()
#   demands_multidepot=pickup_demands()
#   num_vehiclemax,vehicle_capacitys=numvech_max _and_vehiclecap()
#   time_list4={}
#   # [START data_model]
#   def create_data_model():
#     """Stores the data for the problem."""
#     data1 = {}
#     data1['time_windows'] =time_windows_new
#     data1['time_matrix'] = time_matrix2
#     # [START starts_ends]
#     data1['starts'] =multi_depot
#     data1['ends'] =multi_endhub
#     data1['num_vehicles']=num_vehiclemax;
#     data1['demands']=demands_multidepot
#     data1['vehicle_capacities'] =vehicle_capacitys

#     # [END starts_ends]
#     return data1
#     # [END data_model]
 
#  # [START solution_printer]
#  def print_solution(data1, manager, routing, solution,output_list1):
#    total_distance = 0
#    total_load = 0
#    time_dimension = routing.GetDimensionOrDie('Time')
#    total_time = 0
#    time_ss=[]
#     for vehicle_id in range(data1['num_vehicles']):
#        index = routing.Start(vehicle_id)
#        plan_output = 'Route for vehicle {}:\n'.format(vehicle_id)
#        route_load = 0      
#        while not routing.IsEnd(index):
#             node_index = manager.IndexToNode(index)
#             time_var = (time_dimension.CumulVar(index))
#             route_load += data1['demands'][node_index]
#             plan_output += 'Place {0:>2} Arrive at {2:>2}sec Depart at {3:>2}sec (Load {1:>2})\n'.format(manager.IndexToNode(index),  route_load,solution.Min(time_var),solution.Max(time_var))
#             output_list1.append('{0}'.format(manager.IndexToNode(index)))
#             time_ss.append([manager.IndexToNode(index),solution.Max(time_var),route_load])
#             previous_index = index
#             index = solution.Value(routing.NextVar(index))
        
#         time_var = time_dimension.CumulVar(index)
#         total_time += solution.Min(time_var)
#         plan_output +="Place {0:>2} Arrive at {2:>2}sec \n\n".format(manager.IndexToNode(index), route_load,solution.Min(time_var),solution.Max(time_var))
#         plan_output += 'Load of the route: {}\n'.format(route_load)
#         plan_output += 'Time of the route: {}sec\n'.format(solution.Min(time_var))
#         plan_output += "--------------------"
#         time_ss.append([manager.IndexToNode(index),solution.Min(time_var),route_load])
#         time_list4[vehicle_id]=time_ss
#         time_ss=[]
        
        
        
#         # output_list1.append(-1)
#         print(plan_output)
#         total_load += route_load

#     print('Total load of all routes: {}'.format(total_load))
#     print('Total time of all routes: {}sec'.format(total_time))
#     # [END solution_printer]
#   def main():
#     """Entry point of the program."""
#      # Instantiate the data problem.
#      # [START data]
#      data1 = create_data_model()
#      # [END data]

#      # Create the routing index manager.
#      # [START index_manager]
#      manager = pywrapcp.RoutingIndexManager(len(data1['time_matrix']),
#                                            data1['num_vehicles'], data1['starts'],
#                                            data1['ends'])
#      # [END index_manager]

#      # Create Routing Model.
#      # [START routing_model]
#      routing = pywrapcp.RoutingModel(manager)

#      # [END routing_model]

#      # Create and register a transit callback.
#      # [START transit_callback]
#      def time_callback(from_index, to_index):
#        """Returns the travel time between the two nodes."""
#         # Convert from routing variable Index to time matrix NodeIndex.
#         from_node = manager.IndexToNode(from_index)
#         to_node = manager.IndexToNode(to_index)
#         return data1['time_matrix'][from_node][to_node]

#     transit_callback_index = routing.RegisterTransitCallback(time_callback)
#     routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)#

#     # [END transit_callback]
#     # Add Capacity constraint.
#     def demand_callback(from_index):
#         """Returns the demand of the node."""
#         # Convert from routing variable Index to demands NodeIndex.
#         from_node = manager.IndexToNode(from_index)
#         return data1['demands'][from_node]

#     demand_callback_index = routing.RegisterUnaryTransitCallback(
#         demand_callback)
#     routing.AddDimensionWithVehicleCapacity(
#         demand_callback_index,
#         0,  # null capacity slack
#         data1['vehicle_capacities'],  # vehicle maximum capacities
#         True,  # start cumul to zero
#         'Capacity')

#     # Define cost of each arc.
#     # [START arc_cost]
#     routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)
#     # [END arc_cost]

#     # Add Distance constraint.
#     # [START distance_constraint]
#     time = 'Time'
#     routing.AddDimension(
#         transit_callback_index,
#         0,  # allow waiting time
#         300*60,  # maximum time per vehicle
#         False,  # Don't force start cumul to zero.
#         time)
#     time_dimension = routing.GetDimensionOrDie(time)

#     for location_idx, time_window in enumerate(data1['time_windows']):
#         if location_idx == 0:
#             continue
#         index = manager.NodeToIndex(location_idx)
#         time_dimension.CumulVar(index).SetRange(time_window[0], time_window[1])

#     # Add time window constraints for each vehicle start node.
#     for vehicle_id in range(data1['num_vehicles']):
#         index = routing.Start(vehicle_id)
#         time_dimension.CumulVar(index).SetRange(data1['time_windows'][0][0],
#                                                 data1['time_windows'][0][1])

#     # Instantiate route start and end times to produce feasible times.
#     for i in range(data1['num_vehicles']):
#         routing.AddVariableMinimizedByFinalizer(
#             time_dimension.CumulVar(routing.Start(i)))
#         routing.AddVariableMinimizedByFinalizer(
#             time_dimension.CumulVar(routing.End(i)))
  
#     # Setting first solution heuristic.
#     # [START parameters]
#     search_parameters = pywrapcp.DefaultRoutingSearchParameters()
#     search_parameters.first_solution_strategy = (
#         routing_enums_pb2.FirstSolutionStrategy.AUTOMATIC)
#     search_parameters.time_limit.seconds = time_limit_seconds
#     search_parameters.local_search_metaheuristic =(
#     routing_enums_pb2.LocalSearchMetaheuristic.AUTOMATIC)
#     search_parameters.time_limit.seconds = time_limit_seconds
    
#     # [END parameters]

#     # Solve the problem.
#     # [START solve]
#     solution = routing.SolveWithParameters(search_parameters)
#     # [END solve]

#     # Print solution on console.
#     # [START print_solution]
#     if solution:
#         print_solution(data1, manager, routing, solution,output_list1)

#     return solution
#     # [END print_solution]
# solution = main()

# def update_time_list():
#   for key,value in dict(time_list4).items():
#     for j in value:
#       j[0]=list1[int(j[0])]
#   return time_list4

# def update_updated_initial_route_of_delivery():
#   for key,value in dict(updated_initial_route_of_delivery).items():
#     del value[len(value)-1]
#   for key,value in dict(time_list4).items():
#     del value[0]
#     for j in value:
#       updated_initial_route_of_delivery[key].append(j)
#   for key,value in dict(updated_initial_route_of_delivery).items():
#     for j in value:
#       j.append(awb[j[0]])
#       j.append(add[j[0]])
#       j.append(latitude_total[j[0]])
#       j.append(longitude_total[j[0]])
#   return updated_initial_route_of_delivery

# def create_final_csv():
#   for key,value in dict(updated_initial_route_of_delivery).items():
#     Nodes=[]
#     Time=[]
#     Load=[]
#     Address=[]
#     AWB_NO=[]
#     latitude=[]
#     longitude=[]
#     for j in value:
#       Nodes.append(j[0])
#       Time.append(j[1])
#       Load.append(j[2])
#       Address.append(j[4])
#       AWB_NO.append(j[3])
#       latitude.append(j[5])
#       longitude.append(j[6])
#    final_dict = {'Nodes': Nodes, 'Time': Time, 'Load': Load,'AWB_NO':AWB_NO,'Address':Address,'latitude':latitude,'longitude':longitude}  
#    df = pd.DataFrame(final_dict)
#    df.to_csv(f'Final_Driver{key}.csv')